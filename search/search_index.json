{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"[WIP] FastAPI do ZERO","text":""},{"location":"#wip-fastapi-do-zero","title":"[WIP] FastAPI do ZERO","text":"<p>Construindo um Projeto com Bancos de Dados, Testes e Deploy</p> <p>Boas vindas \u00e0 jornada de aprendizado mais empolgante que voc\u00ea vai embarcar: \"FastAPI do Zero: Criando um Projeto com Bancos de Dados, Testes e Deploy\". Este curso tem como objetivo oferecer um entendimento pr\u00e1tico do framework FastAPI, proporcionando as habilidades essenciais para o desenvolvimento eficiente de APIs. Como integra\u00e7\u00e3o com banco de dados e como fazer testes!</p>"},{"location":"#o-que-e-fastapi","title":"O que \u00e9 FastAPI?","text":"<p>FastAPI \u00e9 um framework Python moderno, projetado para simplicidade, velocidade e efici\u00eancia. A combina\u00e7\u00e3o de alto desempenho com anota\u00e7\u00f5es de tipo Python facilita o desenvolvimento de APIs RESTful.</p>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso visa oferecer uma experi\u00eancia pr\u00e1tica completa, desde a configura\u00e7\u00e3o do ambiente de desenvolvimento at\u00e9 o deploy de uma aplica\u00e7\u00e3o FastAPI completa. O objetivo \u00e9 que, ao final do curso, voc\u00ea tenha uma compreens\u00e3o profunda do uso do FastAPI e das melhores pr\u00e1ticas associadas.</p> <p>Para isso, construiremos um projeto pr\u00e1tico de gerenciamento de tarefas (uma lista de tarefas) do zero, incluindo a autentica\u00e7\u00e3o do usu\u00e1rio e opera\u00e7\u00f5es CRUD completas. Nesse projeto, faremos uso das ferramentas mais recentes dispon\u00edveis em 2023, incluindo a vers\u00e3o 0.100 do FastAPI, a vers\u00e3o 2.0 do Pydantic e a vers\u00e3o 2.0 do SQLAlchemy ORM. Tamb\u00e9m usaremos o Python 3.11 e o Alembic para gerenciamento de migra\u00e7\u00f5es.</p> <p>Este curso tamb\u00e9m d\u00e1 \u00eanfase \u00e0 pr\u00e1tica de testes, utilizando o pytest para garantir que as APIs que constru\u00edmos sejam robustas e confi\u00e1veis.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Aqui est\u00e1 uma vis\u00e3o geral dos t\u00f3picos que vamos abordar neste curso:</p> <ol> <li> <p>Configurando um ambiente de desenvolvimento para FastAPI: Vamos come\u00e7ar do absoluto zero, criando e configurando nosso ambiente de desenvolvimento. </p> </li> <li> <p>Primeiros Passos com FastAPI e TDD: Depois de configurar o ambiente, mergulharemos na estrutura b\u00e1sica de um projeto FastAPI e faremos uma introdu\u00e7\u00e3o detalhada ao Test Driven Development (TDD).</p> </li> <li> <p>Modelagem de Dados com Pydantic e SQLAlchemy: Aprenderemos a criar e manipular modelos de dados utilizando Pydantic e SQLAlchemy, dois recursos que levam a efici\u00eancia do FastAPI a um outro n\u00edvel.</p> </li> <li> <p>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o em FastAPI: Vamos construir um sistema de autentica\u00e7\u00e3o completo, para proteger nossas rotas e garantir que apenas usu\u00e1rios autenticados tenham acesso a certos dados.</p> </li> <li> <p>Testando sua Aplica\u00e7\u00e3o FastAPI: Faremos uma introdu\u00e7\u00e3o detalhada aos testes de aplica\u00e7\u00e3o FastAPI, utilizando as bibliotecas pytest e coverage.</p> </li> <li> <p>Dockerizando e Fazendo Deploy de sua Aplica\u00e7\u00e3o FastAPI: Por fim, vamos aprender como \"dockerizar\" nossa aplica\u00e7\u00e3o FastAPI e fazer seu deploy utilizando Fly.io.</p> </li> </ol>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Para aproveitar ao m\u00e1ximo este curso, \u00e9 recomendado que voc\u00ea tenha algum conhecimento pr\u00e9vio de Python. Al\u00e9m disso, algum entendimento b\u00e1sico de desenvolvimento web e APIs RESTful ser\u00e1 \u00fatil, mas n\u00e3o essencial, pois {dizer que a ideia \u00e9 fazer um projeto com foco pr\u00e1tico, ent\u00e3o voc\u00ea pode entender como as coisas s\u00e3o constru\u00eddas at\u00e9 o fim do processo!}</p> Caso esteja iniciando seus estudos em Python! <p>Caso voc\u00ea ainda n\u00e3o se sinta uma pessoa preparada, ou caiu aqui sem saber exatamente o que esperar. Temos um pequeno curso introdut\u00f3rio. Destinado aos primeiros passos com python. </p> <p>Ou ent\u00e3o a leitura do Pense em python</p>"},{"location":"#aulas","title":"Aulas","text":"<ol> <li>Configurando o Ambiente de Desenvolvimento</li> <li>Estruturando seu Projeto e Criando Rotas CRUD</li> <li>Configurando Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic</li> <li>Integrando Banco de Dados a API</li> <li>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o</li> <li>Refatorando a Estrutura do Projeto</li> <li>Tornando o sistema de autentica\u00e7\u00e3o robusto</li> <li>Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI</li> <li>Criando Rotas CRUD para Tarefas</li> <li>Dockerizando a aplica\u00e7\u00e3o</li> <li>Automatizando os testes com integra\u00e7\u00e3o cont\u00ednua</li> <li>Fazendo o deploy no fly.io</li> <li>Despedida</li> </ol>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"\ud83e\udd96 Quem vai ministrar essas aulas?","text":"<p>Prazer! Eu me chamo Eduardo. Mas as pessoas me conhecem na internet como @dunossauro.</p> <p></p> <p>Eu sou um programador Python muito empolgado e curioso. Toco um projeto pessoal chamado Live de Python a pouco mais de 6 anos. Onde conversamos sobre tudo e mais um pouco quando o assunto \u00e9 python.</p> <p>Esse projeto que estamos desenvolvendo \u00e9 um peda\u00e7o, um projeto, de um grande curso de fastAPI que estou montando. Espero que voc\u00ea se divirta ao m\u00e1ximo com a parte pr\u00e1tica enquanto escrevo em mais detalhes todo o potencial te\u00f3rico que lan\u00e7arei no futuro!</p> <p>Caso queira saber mais sobre esse projeto completo.</p>"},{"location":"#licenca","title":"\ud83d\udcd6 Licen\u00e7a","text":"<p>Todo esse curso foi escrito e produzido por Eduardo Mendes (@dunossauro).</p> <p>Todo esse material \u00e9 gratuito e est\u00e1 sob licen\u00e7a Creative Commons BY-NC-SA. O que quer dizer que:</p> <ul> <li>Voc\u00ea pode copiar e reproduzir esse material em qualquer meio e em qualquer formato;</li> <li>Voc\u00ea pode adaptar esse material e construir outros materiais usando esse material.</li> </ul> <p>Pontos de aten\u00e7\u00e3o:</p> <ul> <li>Voc\u00ea precisa dar os devidos cr\u00e9ditos a esse material onde for usar ou adaptar;</li> <li>Voc\u00ea n\u00e3o pode usar para fins comerciais. Como vender ou usar para obter vantagens comerciais;</li> <li>Todo o material derivado desse material deve ser redistribu\u00eddo com a licen\u00e7a CC BY-NC-SA.</li> </ul>"},{"location":"#ferramentas-necessarias-para-acompanhar-o-curso","title":"\ud83e\uddf0 Ferramentas necess\u00e1rias para acompanhar o curso","text":"<ol> <li>Um editor de texto ou IDE de sua escolha. Estou usando o GNU/Emacs enquanto escrevo as aulas;</li> <li>Um terminal. Todos os exemplos do curso s\u00e3o executados e explicados no terminal. Voc\u00ea pode usar o que se sentir mais a vontade e for compat\u00edvel com seu sistema operacional;</li> <li>Ter o interpretador Python instalado em uma vers\u00e3o igual ou superior a <code>3.11</code></li> <li>Uma conta no Github: para podermos testar com github Actions;</li> <li>Uma conta no Fly.io: ferramenta que usaremos para fazer deploy.</li> </ol>"},{"location":"#ferramentas-de-apoio","title":"\ud83d\udd27 Ferramentas de apoio","text":"<p>Toda essa p\u00e1gina foi feita usando as seguintes bibliotecas:</p> <ul> <li>MkDocs: Para gera\u00e7\u00e3o das p\u00e1ginas est\u00e1ticas usando Markdown</li> <li>Mkdocs-material: Tema para o MKDocs</li> <li>pymdown-extensions: Extens\u00f5es para MKDocs, como emojis, diagramas e blocos estilizados de c\u00f3digo</li> <li>Python-Markdown: Extens\u00e3o do Python para Markdown</li> <li>Mkdocs-video: Extens\u00e3o para o MKDocs exibir os v\u00eddeos na p\u00e1gina</li> <li>Mermaid.js: Constru\u00e7\u00e3o dos diagramas</li> </ul>"},{"location":"#repositorio","title":"\ud83d\udcc1 Reposit\u00f3rio","text":"<p>O versionamento de tudo est\u00e1 sendo feito no reposit\u00f3rio do curso Github</p>"},{"location":"#deploy","title":"\ud83d\ude80 Deploy","text":"<p>Os deploys das p\u00e1ginas est\u00e1ticas geradas pelo MkDocs est\u00e3o sendo feitos no Netlify</p>"},{"location":"#conclusao","title":"Conclus\u00e3o","text":"<p>Estou animado para embarcar nesta jornada de aprendizado com voc\u00ea. Se voc\u00ea est\u00e1 pronto para aprender a construir APIs web eficientes e test\u00e1veis com FastAPI, este \u00e9 definitivamente o curso para voc\u00ea. Estou ansioso para come\u00e7ar a primeira aula, onde vamos configurar nosso ambiente de desenvolvimento e dar nossos primeiros passos com FastAPI e TDD!</p>"},{"location":"01/","title":"[OK] Configurando o Ambiente de Desenvolvimento","text":""},{"location":"01/#ok-configurando-o-ambiente-de-desenvolvimento","title":"[OK] Configurando o Ambiente de Desenvolvimento","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao ambiente de desenvolvimento (IDE, terminal, etc.)</li> <li>Instala\u00e7\u00e3o do FastAPI e suas depend\u00eancias</li> <li>Configura\u00e7\u00e3o das ferramentas de desenvolvimento</li> <li>Execu\u00e7\u00e3o do primeiro \"Hello, World!\" com FastAPI com testes!</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Nesta aula pr\u00e1tica, vamos come\u00e7ar nossa jornada na constru\u00e7\u00e3o de uma API com FastAPI. Esse \u00e9 um moderno e r\u00e1pido (altamente perform\u00e1tico) framework web para constru\u00e7\u00e3o de APIs com Python 3.7+ baseado em Python type hints.</p> <p>Partiremos do b\u00e1sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala\u00e7\u00e3o da vers\u00e3o correta do Python at\u00e9 a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Poetry, um gerenciador de pacotes e depend\u00eancias para Python. Al\u00e9m disso, instalaremos e configuraremos uma s\u00e9rie de ferramentas de desenvolvimento \u00fateis, como Ruff, Blue, Isort, pytest e Taskipy.</p> <p>Depois de configurado o nosso ambiente, criaremos nosso primeiro programa \"Hello, World!\" com FastAPI. Isso nos permitir\u00e1 confirmar que tudo est\u00e1 funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.</p>"},{"location":"01/#ambiente-de-desenvolvimento","title":"Ambiente de Desenvolvimento","text":"<p>Para iniciar essa aula voc\u00ea vai precisar de algumas ferramentas.</p> <ol> <li>Um editor de texto a sua escolha (Eu vou usar o GNU/Emacs)</li> <li>Um terminal a sua escolha (Usarei o Terminator)</li> <li>A vers\u00e3o 3.11 do Python instalada.<ul> <li>Caso n\u00e3o tenha essa vers\u00e3o voc\u00ea pode baixar do site oficial</li> <li>Ou instalar via pyenv</li> </ul> </li> <li>O Poetry para gerenciar os pacotes e seu ambiente virtual</li> <li>OPCIONAL: O pipx pode te ajudar bastante nesses momentos</li> <li>Docker</li> </ol>"},{"location":"01/#instalacao-do-python-311","title":"Instala\u00e7\u00e3o do Python 3.11","text":"<p>Se voc\u00ea precisar reconstruir o ambiente usado nesse curso, \u00e9 recomendado que voc\u00ea use o pyenv.</p> <p>Caso tenha problemas durante a instala\u00e7\u00e3o. O pyenv conta com dois assistentes simplificados para sua configura\u00e7\u00e3o. Para windows, use o pyenv-windows. Para GNU/Linux e MacOS, use o pyenv-installer.</p> <p>Navegue at\u00e9 o diret\u00f3rio onde far\u00e1 os exerc\u00edcios e executar\u00e1 os c\u00f3digos de exemplo no seu terminal e digite os seguintes comandos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pyenv update\npyenv install 3.11:latest\npyenv local 3.11.3  # Essa era a maior vers\u00e3o do 3.11 quando escrevi\n</code></pre> <p>Certifique que o python rodando no seu ambiente \u00e9 mesmo o 3.11:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python --version\n</code></pre> <p>A resposta esperada \u00e9 <code>Python 3.11.3</code>.</p>"},{"location":"01/#gerenciamento-de-dependencias-com-poetry","title":"Gerenciamento de Depend\u00eancias com Poetry","text":"<p>Ap\u00f3s instalar o Python, o pr\u00f3ximo passo \u00e9 instalar o Poetry, um gerenciador de pacotes e depend\u00eancias para Python. O Poetry facilita a cria\u00e7\u00e3o, o gerenciamento e a distribui\u00e7\u00e3o de pacotes Python.</p> <p>Para instalar o Poetry, voc\u00ea pode seguir as instru\u00e7\u00f5es presentes na documenta\u00e7\u00e3o oficial do Poetry para o seu sistema operacional. Alternativamente, se voc\u00ea optou por usar o pipx, pode instalar o Poetry com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx install poetry\n</code></pre>"},{"location":"01/#criacao-do-projeto-fastapi-e-instalacao-das-dependencias","title":"Cria\u00e7\u00e3o do Projeto FastAPI e Instala\u00e7\u00e3o das Depend\u00eancias","text":"<p>Agora que temos o Python e o Poetry prontos, podemos come\u00e7ar a criar nosso projeto FastAPI.</p> <p>Vamos inicialmente criar um novo diret\u00f3rio para nosso projeto e navegar para ele:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry new fast_zero\ncd fast_zero\n</code></pre> <p>Ele criar\u00e1 uma estrutura como essa:</p> <pre><code>.\n\u251c\u2500\u2500 fast_zero\n\u2502  \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Em seguida, inicializaremos um novo projeto Python com Poetry e instalaremos as depend\u00eancias necess\u00e1rias - FastAPI e Uvicorn:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry install\npoetry add fastapi uvicorn\n</code></pre>"},{"location":"01/#primeira-execucao-de-um-hello-world","title":"Primeira Execu\u00e7\u00e3o de um \"Hello, World!\"","text":"<p>Para garantir que tudo est\u00e1 configurado corretamente, vamos criar um pequeno programa \"Hello, World!\" com FastAPI. Em um novo arquivo chamado <code>main.py</code>, adicione o seguinte c\u00f3digo:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\napp = FastAPI()\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Agora, podemos iniciar nosso servidor FastAPI com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry shell  # Para ativar o ambiente virtual\nuvicorn fast_zero.app:app --reload\n</code></pre> <p>Acesse http://localhost:8000 no seu navegador, e voc\u00ea deve ver a mensagem \"Hello, World!\" em formato JSON.</p> <p></p>"},{"location":"01/#instalando-as-ferramentas-de-desenvolvimento","title":"Instalando as ferramentas de desenvolvimento","text":"<p>As ferramentas de desenvolvimento escolhidas podem variar de acordo com a prefer\u00eancia pessoal. Nesta aula, utilizaremos algumas que s\u00e3o particularmente \u00fateis para demonstrar certos conceitos:</p> <ul> <li>taskipy: Ferramenta para automatizar alguns comandos e simplificar o fluxo</li> <li>ruff: Um linter, para dizer se n\u00e3o estamos fazendo nada esquisito no c\u00f3digo</li> <li>blue: Um formatador de c\u00f3digo bastante amig\u00e1vel</li> <li>isort: Uma ferramenta para ordenar os imports em ordem alfab\u00e9tica</li> <li>pytest: Ferramenta para executar testes</li> </ul> <p>Para instalar as depend\u00eancias, podemos usar um grupo do poetry focado nelas, para que n\u00e3o sejam usadas em produ\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev pytest pytest-cov taskipy blue ruff httpx\n</code></pre> <p>O <code>HTTPX</code> foi inclu\u00eddo pois ele \u00e9 uma depend\u00eancia do cliente de testes do FastAPI.</p>"},{"location":"01/#configurando-as-ferramentas-de-desenvolvimento","title":"Configurando as ferramentas de desenvolvimento","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o das depend\u00eancias, vamos precisar configurar todas as ferramentas de desenvolvimento no arquivo <code>pyproject.toml</code>.</p>"},{"location":"01/#ruff","title":"Ruff","text":"<p>Vamos usar o ruff na configura\u00e7\u00e3o padr\u00e3o. As \u00fanicas altera\u00e7\u00f5es que faremos ser\u00e3o para que ele siga a PEP-8, usando 80 caracteres por linha e ignorando o ambiente virtual e pasta de migra\u00e7\u00f5es do banco de dados:</p> pyproject.toml<pre><code>[tool.ruff]\nline-length = 79\nexclude = ['.venv', 'migrations']\n</code></pre>"},{"location":"01/#isort","title":"isort","text":"<p>Vamos configurar o isort para o formato do Black, que coloca um import por linha para evitar conflitos no git e tamb\u00e9m usar a base da PEP-8 para 80 caracteres:</p> pyproject.toml<pre><code>[tool.isort]\nprofile = \"black\"\nline_length = 79\n</code></pre>"},{"location":"01/#pytest","title":"pytest","text":"<p>Configuraremos o pytest para reconhecer o caminho base para execu\u00e7\u00e3o dos testes na raiz do projeto <code>.</code>:</p> pyproject.toml<pre><code>[tool.pytest.ini_options]\npythonpath = \".\"\n</code></pre>"},{"location":"01/#blue","title":"blue","text":"<p>Configuraremos o blue para excluir o caminho das migra\u00e7\u00f5es quando essas forem utilizadas:</p> pyproject.toml<pre><code>[tool.blue]\nextend-exclude = '(migrations/)'\n</code></pre>"},{"location":"01/#taskipy","title":"Taskipy","text":"<p>Para simplificar a execu\u00e7\u00e3o de certos comandos, vamos criar algumas tarefas com o Taskipy.</p> pyproject.toml<pre><code>[tool.taskipy.tasks]\nlint = 'ruff . &amp;&amp; blue --check . --diff'\nformat = 'blue .  &amp;&amp; isort .'\nrun = 'uvicorn fast_zero.app:app --reload'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n</code></pre> <p>Os comandos definidos fazem o seguinte:</p> <ul> <li>lint: executa o ruff para ver se n\u00e3o temos nenhum problema com o c\u00f3digo e checa se estamos de acordo com a PEP-8</li> <li>format: formata o c\u00f3digo usando blue e isort</li> <li>run: executa o servidor de desenvolvimento do FastAPI</li> <li>pre_test: executa a camada de lint antes de executar os teste</li> <li>test: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c\u00f3digo como base de cobertura</li> <li>post_test: gera um report de cobertura ap\u00f3s os testes</li> </ul> <p>Para executar um comando, \u00e9 bem mais simples, precisando somente passar a palavra <code>task &lt;comando&gt;</code>.</p> Caso precise do arquivo todo <p>O meu est\u00e1 exatamente assim:</p> pyproject.toml<pre><code>[tool.poetry]\nname = \"fast-zero\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"dunossauro &lt;mendesxeduardo@gmail.com&gt;\"]\nreadme = \"README.md\"\npackages = [{include = \"fast_zero\"}]\n[tool.poetry.dependencies]\npython = \"^3.11\"\nfastapi = \"^0.100.0\"\nuvicorn = \"^0.22.0\"\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-cov = \"^4.1.0\"\ntaskipy = \"^1.11.0\"\nblue = \"^0.9.1\"\nruff = \"^0.0.278\"\nhttpx = \"^0.24.1\"\n[tool.ruff]\nline-length = 79\nexclude = ['.venv', 'migrations']\n[tool.isort]\nprofile = \"black\"\nline_length = 79\n[tool.pytest.ini_options]\npythonpath = \".\"\n[tool.blue]\nextend-exclude = '(migrations/)'\n[tool.taskipy.tasks]\nlint = 'ruff . &amp;&amp; blue --check . --diff'\nformat = 'blue .  &amp;&amp; isort .'\nrun = 'uvicorn fast_zero.app:app --reload'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>"},{"location":"01/#os-efeitos-dessas-configuracoes-de-desenvolvimento","title":"Os efeitos dessas configura\u00e7\u00f5es de desenvolvimento","text":"<p>Caso voc\u00ea tenha copiado o c\u00f3digo que usamos para definir <code>fast_zero/app.py</code>, pode testar os comandos que criamos para o <code>taskipy</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\n</code></pre> <p>Dessa forma, veremos que cometemos algumas infra\u00e7\u00f5es na formata\u00e7\u00e3o da PEP-8. O blue nos informar\u00e1 que dever\u00edamos ter adicionado duas linhas antes de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o:</p> <pre><code>task lint\n--- fast_zero/app.py    2023-07-12 21:40:14.590616 +0000\n+++ fast_zero/app.py    2023-07-12 21:48:17.017190 +0000\n@@ -1,7 +1,8 @@\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n+\n@app.get('/')\n def read_root():\n     return {'message': 'Ol\u00e1 Mundo!'}\nwould reformat fast_zero/app.py\n\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file would be reformatted, 2 files would be left unchanged.\n</code></pre> <p>Para corrigir isso, podemos usar o nosso comando de formata\u00e7\u00e3o de c\u00f3digo:</p> ComandoResultado $ Execu\u00e7\u00e3o no terminal!<pre><code>task format\nreformatted fast_zero/app.py\n\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file reformatted, 2 files left unchanged.\nSkipped 2 files\n</code></pre> fast_zero/app.py<pre><code>from fastapi import FastAPI\napp = FastAPI()\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre>"},{"location":"01/#introducao-ao-pytest-testando-o-hello-world","title":"Introdu\u00e7\u00e3o ao Pytest: Testando o \"Hello, World!\"","text":"<p>Antes de entendermos a din\u00e2mica dos testes, precisamos entender o efeito que eles tem no nosso c\u00f3digo. Um bom lugar para come\u00e7ar isso \u00e9 analisando a cobertura. Vamos executar os testes.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Teremos uma resposta como essa:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>All done! \u2728 \ud83c\udf70 \u2728\n3 files would be left unchanged.\n=========================== test session starts ===========================\nplatform linux -- Python 3.11.3, pytest-7.4.0, pluggy-1.2.\ncachedir: .pytest_cache\nrootdir: /home/dunossauro/git/fast_zero\nconfigfile: pyproject.toml\nplugins: cov-4.1.0, anyio-3.7.1\ncollected 0 items\n\n/&lt;path&gt;/site-packages/coverage/control.py:860:\n  CoverageWarning: No data was collected. (no-data-collected)\nself._warn(\"No data was collected.\", slug=\"no-data-collected\")\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      5     0%\n-------------------------------------------\nTOTAL                       5      5     0%\n</code></pre> <p>As primeiras duas linhas s\u00e3o referentes ao comando do <code>taskipy</code> <code>pre_test</code> que executa o <code>blue</code> e o <code>ruff</code> antes de cada teste. As linhas seguintes s\u00e3o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.</p> <p>A parte importante dessa Mensagem est\u00e1 na tabela gerada pelo <code>coverage</code>. Que diz que temos 5 linhas de c\u00f3digo (Stmts) no arquivo <code>fast_zero/app.py</code> e nenhuma delas est\u00e1 coberta pelos nosso testes. Como podemos ver na coluna <code>Miss</code>.</p> <p>Por n\u00e3o ter encontrado nenhum teste, o pytest retornou um \"erro\". Isso significa que nossa tarefa <code>post_test</code> n\u00e3o foi executada. Podemos execut\u00e1-la manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Isso gera um relat\u00f3rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c\u00f3digo n\u00e3o est\u00e3o sendo testadas.</p> <p></p> <p>Se clicarmos no arquivo <code>fast_zero/app.py</code> podemos ver em vermelho as linhas que n\u00e3o est\u00e3o sendo testadas</p> <p></p> <p>Isto significa que precisamos testar todo esse arquivo.</p>"},{"location":"01/#escrevendo-o-teste","title":"Escrevendo o teste","text":"<p>Agora, vamos escrever nosso primeiro teste com Pytest.</p> <p>Para testar o fastAPI, precisamos de um cliente de teste. Isso pode ser obtido no m\u00f3dulo <code>fastapi.testclient</code> com o objeto <code>TestClient</code>, que precisa receber nosso app como par\u00e2metro:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\nclient = TestClient(app)\n</code></pre> <p>S\u00f3 o fato de termos definido um cliente, j\u00e1 nos mostra uma cobertura bastante diferente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 0 items\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      1    80%\n-------------------------------------------\nTOTAL                       5      1    80%\n</code></pre> <p>Devido ao fato de n\u00e3o ter coletado nenhum teste, o pytest ainda retornou um \"erro\". Para ver a cobertura, precisaremos executar novamente o <code>post_test</code> manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>No navegador, podemos ver que a \u00fanica linha n\u00e3o \"testada\" \u00e9 aquela onde temos a l\u00f3gica do endpoint:</p> <p></p> <p>No verde vemos o que foi executado quando chamamos o teste, no vermelho o que n\u00e3o foi.</p> <p>Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\nclient = TestClient(app)\ndef test_root_deve_retornar_200_e_ola_mundo():\nresponse = client.get('/')\nassert response.status_code == 200\nassert response.json() == {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Esse teste faz uma requisi\u00e7\u00e3o GET no endpoint <code>/</code> e verifica se o c\u00f3digo de status da resposta \u00e9 200 e se o conte\u00fado da resposta \u00e9 <code>{'message': 'Ol\u00e1 Mundo!'}</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 1 item\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      0   100%\n-------------------------------------------\nTOTAL                       5      0   100%\n\n================ 1 passed in 1.39s ================\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n\u00e3o deixou de abranger nenhuma linha de c\u00f3digo.</p> <p>Como conseguimos coletar um item, o <code>post_test</code> foi executado e tamb\u00e9m gerou um HTML com a cobertura atualizada.</p> <p></p>"},{"location":"01/#criando-nosso-repositorio-no-git","title":"Criando nosso reposit\u00f3rio no git","text":"<p>Antes de concluirmos a aula, precisamos criar nosso reposit\u00f3rio no git e criar nosso arquivo <code>.gitignore</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>ignr -p python &gt; .gitignore\ngit init .\ngh repo create\n</code></pre>"},{"location":"01/#conclusao","title":"Conclus\u00e3o","text":"<p>Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come\u00e7ar a trabalhar com FastAPI e j\u00e1 fizemos nossa primeira imers\u00e3o no Desenvolvimento Orientado por Testes. Na pr\u00f3xima aula, vamos aprofundar na estrutura\u00e7\u00e3o da nossa aplica\u00e7\u00e3o FastAPI. At\u00e9 l\u00e1!</p>"},{"location":"02/","title":"[OK] Estruturando seu Projeto e Criando Rotas CRUD","text":""},{"location":"02/#ok-estruturando-seu-projeto-e-criando-rotas-crud","title":"[OK] Estruturando seu Projeto e Criando Rotas CRUD","text":"<p>Objetivos dessa aula:</p> <ul> <li>Entendimento dos verbos HTTP, JSON e c\u00f3digos de resposta</li> <li>Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)</li> <li>Aprender sobre a biblioteca Pydantic e sua utilidade na valida\u00e7\u00e3o e serializa\u00e7\u00e3o de dados</li> <li>Implementa\u00e7\u00e3o de rotas CRUD em FastAPI</li> <li>Escrita e execu\u00e7\u00e3o de testes para validar o comportamento das rotas</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Boas vindas de volta \u00e0 nossa s\u00e9rie de cursos \"FastAPI do Zero: Criando um Projeto com Bancos de Dados, Testes e Deploy\". Hoje, na Aula 3, vamos avan\u00e7ar na estrutura\u00e7\u00e3o do nosso projeto FastAPI e implementar todas as rotas CRUD (Criar, Ler, Atualizar e Deletar) para o nosso recurso de usu\u00e1rio.</p>"},{"location":"02/#o-que-e-uma-api","title":"O que \u00e9 uma API?","text":"<p>Acr\u00f4nimo de Application Programming Interface (Interface de Programa\u00e7\u00e3o de Aplica\u00e7\u00f5es), uma API \u00e9 um conjunto de regras e protocolos que permitem a comunica\u00e7\u00e3o entre diferentes softwares. As APIs servem como uma ponte entre diferentes programas, permitindo que eles se comuniquem e compartilhem informa\u00e7\u00f5es de maneira eficiente e segura.</p> <p>No mundo moderno, as APIs geralmente comunicam usando o formato de dados JSON (JavaScript Object Notation), que \u00e9 uma maneira leve e eficiente de transmitir dados entre a API e o cliente.</p> <p>As APIs s\u00e3o fundamentais no mundo da programa\u00e7\u00e3o moderna, pois permitem a intera\u00e7\u00e3o entre diferentes sistemas, independentemente de como foram projetados ou em que linguagem foram escritos.</p>"},{"location":"02/#o-que-e-http","title":"O que \u00e9 HTTP?","text":"<p>HTTP, ou Hypertext Transfer Protocol (Protocolo de Transfer\u00eancia de Hipertexto), \u00e9 o protocolo fundamental na web para a transfer\u00eancia de dados e comunica\u00e7\u00e3o entre clientes e servidores.</p> <p>No contexto das APIs, o HTTP \u00e9 o protocolo que permite a comunica\u00e7\u00e3o entre o cliente (geralmente o navegador de um usu\u00e1rio, mas pode ser qualquer coisa que saiba como fazer solicita\u00e7\u00f5es HTTP) e o servidor onde a API est\u00e1 hospedada. As informa\u00e7\u00f5es entre o cliente e o servidor s\u00e3o trocadas na forma de JSON, tornando-se uma linguagem universal para a troca de informa\u00e7\u00f5es na web.</p> <p>O HTTP \u00e9 baseado no modelo de requisi\u00e7\u00e3o-resposta: o cliente faz uma requisi\u00e7\u00e3o para o servidor, e o servidor responde a essa requisi\u00e7\u00e3o. Essas requisi\u00e7\u00f5es e respostas s\u00e3o formatadas de acordo com as regras do protocolo HTTP.</p> <p>A seguir, vamos explorar como os verbos HTTP, os c\u00f3digos de resposta e os c\u00f3digos de erro s\u00e3o utilizados para gerenciar a comunica\u00e7\u00e3o entre o cliente e a API.</p>"},{"location":"02/#compreendendo-os-verbos-http-codigos-de-resposta-e-codigos-de-erro","title":"Compreendendo os Verbos HTTP, C\u00f3digos de Resposta e C\u00f3digos de Erro","text":"<p>Quando trabalhamos com APIs REST, o uso apropriado dos verbos HTTP, c\u00f3digos de resposta e c\u00f3digos de erro \u00e9 crucial para criar uma API clara e consistente. </p>"},{"location":"02/#verbos-http","title":"Verbos HTTP","text":"<p>Os verbos HTTP indicam a a\u00e7\u00e3o desejada a ser executada em um determinado recurso. Os verbos mais comuns s\u00e3o:</p> <ul> <li>GET: Recupera recursos. Deve retornar o status HTTP 200 (OK) se bem-sucedido.</li> <li>POST: Cria um novo recurso. Deve retornar o status HTTP 201 (Criado) se bem-sucedido.</li> <li>PUT: Atualiza um recurso existente. Deve retornar o status HTTP 200 (OK) se bem-sucedido.</li> <li>DELETE: Exclui um recurso. Deve retornar o status HTTP 200 (OK) se bem-sucedido.</li> </ul>"},{"location":"02/#codigos-de-resposta-http","title":"C\u00f3digos de Resposta HTTP","text":"<p>Os c\u00f3digos de resposta HTTP informam ao cliente sobre o resultado de sua solicita\u00e7\u00e3o. Aqui est\u00e3o alguns dos c\u00f3digos de resposta mais comuns:</p> <ul> <li>200 OK: A solicita\u00e7\u00e3o foi bem-sucedida. O significado exato depende do m\u00e9todo HTTP utilizado na solicita\u00e7\u00e3o.</li> <li>201 Created: A solicita\u00e7\u00e3o foi bem-sucedida e um novo recurso foi criado como resultado.</li> <li>404 Not Found: O recurso solicitado n\u00e3o p\u00f4de ser encontrado. Este c\u00f3digo \u00e9 frequentemente usado quando o recurso \u00e9 inexistente.</li> </ul>"},{"location":"02/#codigos-de-erro-http","title":"C\u00f3digos de Erro HTTP","text":"<p>Os c\u00f3digos de erro HTTP indicam que houve um problema com a solicita\u00e7\u00e3o. Alguns c\u00f3digos de erro comuns incluem:</p> <ul> <li>400 Bad Request: A solicita\u00e7\u00e3o era inv\u00e1lida ou malformada.</li> <li>401 Unauthorized: A solicita\u00e7\u00e3o requer autentica\u00e7\u00e3o. Se a solicita\u00e7\u00e3o inclu\u00eda credenciais de autentica\u00e7\u00e3o e mesmo assim retornou 401, isso significa que as credenciais n\u00e3o foram aceitas.</li> <li>403 Forbidden: O cliente n\u00e3o tem permiss\u00f5es para acessar o recurso solicitado, apesar de estar autenticado.</li> <li>404 Not Found: O recurso solicitado n\u00e3o existe no servidor.</li> <li>422 Unprocessable Entity: A solicita\u00e7\u00e3o est\u00e1 bem formada, mas os par\u00e2metros sem\u00e2nticos s\u00e3o inv\u00e1lidos ou incompat\u00edveis.</li> <li>500 Internal Server Error: Ocorreu um erro inesperado no servidor.</li> </ul> <p>Ao trabalhar com APIs REST, \u00e9 importante lidar corretamente com esses c\u00f3digos de resposta e erro para proporcionar uma boa experi\u00eancia para os usu\u00e1rios da API.</p>"},{"location":"02/#como-acontece-a-comunicacao-web-entre-cliente-e-servidor","title":"Como acontece a comunica\u00e7\u00e3o web entre cliente e servidor","text":"<p>A comunica\u00e7\u00e3o entre cliente e servidor na web \u00e9 um processo que ocorre em v\u00e1rias etapas e \u00e9 governado por protocolos de comunica\u00e7\u00e3o espec\u00edficos. O protocolo mais comum \u00e9 o HTTP (Hypertext Transfer Protocol). Essa forma de comunica\u00e7\u00e3o \u00e9 geralmente descrita como stateless, o que significa que cada requisi\u00e7\u00e3o \u00e9 processada de forma independente, sem qualquer conhecimento das requisi\u00e7\u00f5es anteriores.</p> <p>A informa\u00e7\u00e3o \u00e9 trocada na forma de mensagens HTTP, que cont\u00eam dados e informa\u00e7\u00f5es sobre como esses dados devem ser processados. Um aspecto fundamental dessa comunica\u00e7\u00e3o \u00e9 a troca de dados na forma de objetos JSON, que s\u00e3o uma maneira eficiente e flex\u00edvel de representar dados estruturados.</p> <pre><code>sequenceDiagram\n    participant Cliente\n    participant Servidor\n    Cliente-&gt;&gt;Servidor: Requisi\u00e7\u00e3o HTTP (GET, POST, PUT, DELETE)\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Resposta HTTP (C\u00f3digo de Status)\n    Note left of Cliente: Processa a resposta\n    Cliente-&gt;&gt;Servidor: Requisi\u00e7\u00e3o HTTP com JSON (POST, PUT)\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o e o JSON\n    Servidor--&gt;&gt;Cliente: Resposta HTTP com JSON\n    Note left of Cliente: Processa a resposta e o JSON</code></pre> <p>Este diagrama representa a sequ\u00eancia b\u00e1sica de uma comunica\u00e7\u00e3o cliente-servidor usando HTTP e JSON:</p> <ul> <li>O cliente, geralmente um navegador web ou uma aplica\u00e7\u00e3o, faz uma requisi\u00e7\u00e3o HTTP para o servidor. Essa requisi\u00e7\u00e3o pode ser de diferentes tipos, como GET (para recuperar dados), POST ou PUT (para enviar dados), ou DELETE (para excluir dados).</li> <li>O servidor recebe a requisi\u00e7\u00e3o, processa-a e, em seguida, prepara a resposta. A resposta inclui um c\u00f3digo de status que indica se a requisi\u00e7\u00e3o foi bem-sucedida ou n\u00e3o.</li> <li>O cliente recebe a resposta do servidor e processa-a. Se os dados foram solicitados, eles s\u00e3o exibidos ao usu\u00e1rio. Se foi uma opera\u00e7\u00e3o de envio de dados, a resposta do servidor indicar\u00e1 se a opera\u00e7\u00e3o foi bem-sucedida.</li> <li>Para opera\u00e7\u00f5es que envolvem o envio de dados (como POST e PUT), o cliente inclui os dados na forma de um objeto JSON na requisi\u00e7\u00e3o. O JSON \u00e9 um formato de dados leve e f\u00e1cil de usar que permite a representa\u00e7\u00e3o de estruturas de dados complexas.</li> <li>O servidor recebe a requisi\u00e7\u00e3o com os dados JSON, processa a requisi\u00e7\u00e3o e os dados, e envia uma resposta ao cliente. Esta resposta tamb\u00e9m pode incluir dados no formato JSON.</li> <li>Finalmente, o cliente processa a resposta do servidor e quaisquer dados JSON inclu\u00eddos nela.</li> </ul> <p>Essa \u00e9 uma vis\u00e3o geral simplificada do processo. Na pr\u00e1tica, a comunica\u00e7\u00e3o entre cliente e servidor pode envolver muitas outras nuances, como autentica\u00e7\u00e3o, redirecionamento, cookies e muito mais.</p>"},{"location":"02/#pydantic-e-a-validacao-de-dados","title":"Pydantic e a valida\u00e7\u00e3o de dados","text":"<p>Antes de mergulharmos no c\u00f3digo, vamos entender alguns conceitos importantes.</p> <p>O Pydantic \u00e9 uma biblioteca Python que oferece valida\u00e7\u00e3o de dados e configura\u00e7\u00f5es usando anota\u00e7\u00f5es de tipos Python. Ela \u00e9 utilizada extensivamente em FastAPI para lidar com a valida\u00e7\u00e3o e serializa\u00e7\u00e3o/desserializa\u00e7\u00e3o de dados. O Pydantic tem um papel crucial ao trabalhar com JSON, pois permite a valida\u00e7\u00e3o dos dados recebidos neste formato, assim como sua convers\u00e3o para formatos nativos do Python e vice-versa.</p> <p>Esquemas: No contexto da programa\u00e7\u00e3o, um esquema \u00e9 uma representa\u00e7\u00e3o estrutural de um objeto ou entidade. Por exemplo, no nosso caso, um usu\u00e1rio pode ser representado por um esquema que cont\u00e9m campos para nome de usu\u00e1rio, e-mail e senha. Esquemas s\u00e3o \u00fateis porque permitem definir a estrutura de um objeto de uma maneira clara e reutiliz\u00e1vel.</p> <p>Valida\u00e7\u00e3o de dados: Este \u00e9 o processo de verificar se os dados recebidos est\u00e3o em conformidade com as regras e restri\u00e7\u00f5es definidas. Por exemplo, se esperamos que o campo \"email\" contenha um endere\u00e7o de e-mail v\u00e1lido, a valida\u00e7\u00e3o de dados garantir\u00e1 que os dados inseridos nesse campo de fato correspondam a um formato de e-mail v\u00e1lido.</p> <p>Agora, vamos falar sobre a biblioteca Pydantic.</p> <p>O Pydantic \u00e9 uma biblioteca Python que oferece valida\u00e7\u00e3o de dados e configura\u00e7\u00f5es usando anota\u00e7\u00f5es de tipos Python. Ela \u00e9 utilizada extensivamente em FastAPI para lidar com a valida\u00e7\u00e3o e serializa\u00e7\u00e3o/desserializa\u00e7\u00e3o de dados.</p> <p>O uso do Pydantic nos permite definir modelos de dados, ou \"esquemas\", com campos anotados com tipos de dados. O Pydantic garante que as inst\u00e2ncias desses modelos sempre estejam em conformidade com o esquema definido.</p> <p>Vamos considerar um exemplo onde recebemos o seguinte objeto JSON, representando um novo usu\u00e1rio que quer se registrar em nosso servi\u00e7o:</p> <pre><code>{\n\"username\": \"joao123\",\n\"email\": \"joao123@email.com\",\n\"password\": \"segredo123\"\n}\n</code></pre> <p>Para lidar com esta entrada de dados, devemos definir um esquema Pydantic que corresponda \u00e0 estrutura deste objeto JSON. Usamos anota\u00e7\u00f5es de tipos Python para definir o tipo de dado de cada campo:</p> <pre><code>from pydantic import BaseModel, EmailStr\nclass UserSchema(BaseModel):\nusername: str\nemail: EmailStr\npassword: str\n</code></pre> <p>Neste exemplo, o campo <code>username</code> \u00e9 esperado como uma string, o campo <code>email</code> como uma string que valida o formato de um endere\u00e7o de email (gra\u00e7as \u00e0 anota\u00e7\u00e3o <code>EmailStr</code> do Pydantic), e o campo <code>password</code> tamb\u00e9m \u00e9 esperado como uma string.</p> <p>Ao usar este esquema, qualquer tentativa de criar um usu\u00e1rio com dados que n\u00e3o correspondam a este formato (por exemplo, um email que n\u00e3o \u00e9 v\u00e1lido, ou um campo de nome de usu\u00e1rio que n\u00e3o \u00e9 uma string) resultar\u00e1 em um erro de valida\u00e7\u00e3o.</p>"},{"location":"02/#suporte-a-emails","title":"Suporte a emails","text":"<p>Para que o pydantic suporte a valida\u00e7\u00e3o de emails, \u00e9 necess\u00e1rio instalar o <code>pydantic[email]</code></p> <p>Ademais, se tentarmos criar um usu\u00e1rio com um email inv\u00e1lido, o Pydantic ir\u00e1 automaticamente validar o campo e retornar um erro \u00fatil. Isso nos poupa muito trabalho de valida\u00e7\u00e3o manual e ajuda a manter nossa API robusta e confi\u00e1vel.</p>"},{"location":"02/#implementando-as-rotas-crud","title":"Implementando as Rotas CRUD","text":"<p>CRUD \u00e9 um acr\u00f4nimo que representa as quatro opera\u00e7\u00f5es b\u00e1sicas que voc\u00ea pode realizar em qualquer banco de dados persistente:</p> <ul> <li>Create (Criar): Adicionar novos registros ao banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo POST.</li> <li>Read (Ler): Recuperar registros existentes do banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo GET.</li> <li>Update (Atualizar): Modificar registros existentes no banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo PUT ou PATCH.</li> <li>Delete (Excluir): Remover registros existentes do banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo DELETE.</li> </ul> <p>Os c\u00f3digos de status HTTP s\u00e3o usados para indicar o resultado de cada opera\u00e7\u00e3o CRUD. Por exemplo, uma solicita\u00e7\u00e3o POST bem-sucedida (create) retorna o status HTTP 201 (Criado), enquanto uma solicita\u00e7\u00e3o GET bem-sucedida (read) retorna o status HTTP 200 (OK).</p> <p>\u00c9 importante notar que, ao trabalhar com FastAPI e Pydantic, nossos esquemas desempenham um papel vital na opera\u00e7\u00e3o de \"Create\" (criar). Ao usar a opera\u00e7\u00e3o POST para adicionar um novo registro ao nosso banco de dados, vamos aproveitar a valida\u00e7\u00e3o de dados do Pydantic para garantir que o novo registro esteja em conformidade com o esquema do nosso modelo de dados. Se os dados enviados na solicita\u00e7\u00e3o POST n\u00e3o passarem na valida\u00e7\u00e3o do Pydantic, nossa API retornar\u00e1 um c\u00f3digo de status HTTP 422 (Unprocessable Entity), indicando que os dados fornecidos s\u00e3o inv\u00e1lidos ou incompletos.</p> <p>Agora que temos uma compreens\u00e3o clara do que \u00e9 o CRUD, como se relaciona com os verbos HTTP, os c\u00f3digos de status e a valida\u00e7\u00e3o do Pydantic, podemos passar para a implementa\u00e7\u00e3o dessas opera\u00e7\u00f5es em nossa API FastAPI.</p> <p>Na nossa API, vamos criar rotas correspondentes para cada opera\u00e7\u00e3o CRUD, come\u00e7ando com a opera\u00e7\u00e3o \"create\" (criar), que ser\u00e1 implementada pela rota POST.</p>"},{"location":"02/#implementando-a-rota-post","title":"Implementando a Rota POST","text":"<p>A rota POST \u00e9 usada para criar um novo usu\u00e1rio em nosso sistema. Lembrando, o verbo HTTP POST est\u00e1 relacionado \u00e0 opera\u00e7\u00e3o \"Create\" do CRUD. Se tudo ocorrer como esperado e um novo usu\u00e1rio for criado com sucesso, a rota deve retornar o status HTTP 201 (Criado).</p> <p>Para a cria\u00e7\u00e3o dessa rota, vamos usar de base o JSON que criamos anteriormente. Para que a pessoa se cadastre na nossa plataforma, ela precisa enviar os dados de nome de usu\u00e1rio, email e senha:</p> <pre><code>{\n\"username\": \"joao123\",\n\"email\": \"joao123@email.com\",\n\"password\": \"segredo123\"\n}\n</code></pre> <p>Para isso, vamos criar um esquema Pydantic equivalente em um arquivo de esquemas: <code>fast_zero/schemas.py</code>:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, EmailStr\nclass UserSchema(BaseModel):\nusername: str\nemail: EmailStr\npassword: str\n</code></pre> <p>Agora vamos criar nosso endpoint que esperar\u00e1 receber esse esquema Pydantic e retornar\u00e1 201, caso o JSON enviado seja v\u00e1lido:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\nemafrom fast_zero.schemas import UserSchema\n# C\u00f3digo da nossa rota de ol\u00e1 mundo omitido\n@app.post('/users/', status_code=201)\ndef create_user(user: UserSchema):\nreturn user\n</code></pre> <p>Com esse endpoint criado, podemos executar a nossa aplica\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre> <p>E acessar a p\u00e1gina http://localhost:8000/docs. Isso nos mostrar\u00e1 as defini\u00e7\u00f5es do nosso endpoint usando o Swagger.</p> <p></p> <p>Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.</p> <p></p> <p>Entretanto, precisamos prestar aten\u00e7\u00e3o a um detalhe: nosso modelo retorna a senha do usu\u00e1rio, o que \u00e9 uma p\u00e9ssima pr\u00e1tica de seguran\u00e7a. </p> <p></p> <p>Para evitar isso, podemos criar um novo modelo que ser\u00e1 usado somente para resposta. Dessa forma, n\u00e3o expomos os dados que n\u00e3o queremos na API:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\nusername: str\nemail: EmailStr\n</code></pre> <p>Precisamos tamb\u00e9m dizer ao FastAPI que esse ser\u00e1 o modelo de resposta, e converter nosso <code>user</code> em <code>UserPublic</code>:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic\n# c\u00f3digo omitido\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\nreturn UserPublic(**user.model_dump())\n</code></pre> <p>Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.</p> <p></p>"},{"location":"02/#criando-um-banco-de-dados-falso","title":"Criando um banco de dados falso","text":"<p>Finalmente, para brincar com essas rotas, podemos criar uma lista provis\u00f3ria para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provis\u00f3ria para o \"banco\" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic, UserDB\n# c\u00f3digo omitido\ndatabase = []  # provis\u00f3rio para estudo!\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\nuser_with_id = UserDB(**user.model_dump(), id=len(database) + 1)\ndatabase.append(user_with_id)\nreturn UserPublic(**user_with_id.model_dump())\n</code></pre> <p>Se queremos uma simula\u00e7\u00e3o de banco de dados, precisamos ter um <code>ID</code> para cada usu\u00e1rio registrado no nosso \"banco\". Sendo assim, vamos alterar nosso modelo de resposta p\u00fablica (<code>UserPublic</code>) para que ele forne\u00e7a o ID de cria\u00e7\u00e3o do usu\u00e1rio. Vamos tamb\u00e9m criar um novo modelo que represente o usu\u00e1rio com sua senha e identificador, que chamaremos de <code>UserDB</code>:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\nid: int\nusername: str\nemail: EmailStr\nclass UserDB(UserSchema):\nid: int\n</code></pre> <p>Dessa forma, nada muda. No entanto, podemos prosseguir com a constru\u00e7\u00e3o dos outros endpoints. E lembre-se, \u00e9 importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.</p>"},{"location":"02/#implementando-o-teste-da-rota-post","title":"Implementando o teste da rota POST","text":"<p>Antes de criar o teste de fato, vamos execut\u00e1-los para ver como anda a nossa cobertura:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da resposta foi omitida\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      3    75%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      3    87%\n\n# parte da resposta foi omitida\n</code></pre> <p>Vemos que temos 3 Miss. Poss\u00edvelmente das linhas que acabamos de escrever.</p> <p></p> <p>Ent\u00e3o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a cria\u00e7\u00e3o de um novo usu\u00e1rio funciona corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o POST com um novo usu\u00e1rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta cont\u00e9m o novo usu\u00e1rio criado.</p> tests/test_app.py<pre><code>def test_create_user():\nresponse = client.post(\n'/users/',\njson={\n'username': 'alice',\n'email': 'alice@example.com',\n'password': 'secret',\n},\n)\nassert response.status_code == 201\nassert response.json() == {\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\n</code></pre> <p>Ao executar o teste:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da resposta foi omitida\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      0   100%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      0   100%\n\n# parte da resposta foi omitida\n</code></pre> <p>Vemos que estamos no caminho certo. Agora que a rota POST est\u00e1 implementada, vamos seguir para a pr\u00f3xima opera\u00e7\u00e3o CRUD: Read.</p>"},{"location":"02/#implementando-a-rota-get","title":"Implementando a Rota GET","text":"<p>A rota GET \u00e9 usada para recuperar informa\u00e7\u00f5es de um ou mais usu\u00e1rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Read\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).</p> <p>Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado <code>UserList</code>. Este modelo representar\u00e1 uma lista de usu\u00e1rios e cont\u00e9m apenas um campo chamado <code>users</code>, que \u00e9 uma lista de <code>UserPublic</code>. Isso nos permite retornar m\u00faltiplos usu\u00e1rios de uma vez.</p> fast_zero/schemas.py<pre><code>class UserList(BaseModel):\nusers: list[UserPublic]\n</code></pre> <p>Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornar\u00e1 uma inst\u00e2ncia de <code>UserList</code>, que por sua vez cont\u00e9m uma lista de <code>UserPublic</code>. Cada <code>UserPublic</code> \u00e9 criado a partir dos dados de um usu\u00e1rio em nosso banco de dados fict\u00edcio.</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList\n# c\u00f3digo omitido\n@app.get('/users/', response_model=UserList)\ndef read_users():\nreturn UserList(  # provis\u00f3rio\nusers=[UserPublic(**data.model_dump()) for data in database]\n)\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, nossa API agora pode retornar uma lista de usu\u00e1rios. No entanto, nosso trabalho ainda n\u00e3o acabou. A pr\u00f3xima etapa \u00e9 escrever testes para garantir que nossa rota GET est\u00e1 funcionando corretamente. Isso nos ajudar\u00e1 a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementa\u00e7\u00e3o de outras rotas.</p>"},{"location":"02/#implementando-o-teste-da-rota-de-get","title":"Implementando o teste da rota de GET","text":"<p>Nosso teste da rota GET tem que verificar se a recupera\u00e7\u00e3o dos usu\u00e1rios est\u00e1 funcionando corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m a lista de usu\u00e1rios.</p> tests/test_app.py<pre><code>def test_read_users():\nresponse = client.get('/users/')\nassert response.status_code == 200\nassert response.json() == {\n'users': [\n{\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\n]\n}\n</code></pre> <p>Com as rotas POST e GET implementadas, agora podemos criar e recuperar usu\u00e1rios. Vamos implementar a pr\u00f3xima opera\u00e7\u00e3o CRUD: Update.</p>"},{"location":"02/#implementando-a-rota-put","title":"Implementando a Rota PUT","text":"<p>A rota PUT \u00e9 usada para atualizar as informa\u00e7\u00f5es de um usu\u00e1rio existente. No contexto do CRUD, o verbo HTTP PUT est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Update\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> fast_zero/app.py<pre><code>from fastapi import FastAPI, HTTPException\n# ...\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(user_id: int, user: UserSchema):\nif user_id &gt; len(database) or user_id &lt; 1:\nraise HTTPException(status_code=404, detail='User not found')\nuser_with_id = UserPublic(**user.model_dump(), id=user_id)\ndatabase[user_id - 1] = user_with_id\nreturn UserPublic(**user_with_id.model_dump())\n</code></pre>"},{"location":"02/#implementando-o-teste-da-rota-de-put","title":"Implementando o teste da rota de PUT","text":"<p>Nosso teste da rota PUT precisa verificar se a atualiza\u00e7\u00e3o de um usu\u00e1rio existente funciona corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o PUT com as novas informa\u00e7\u00f5es do usu\u00e1rio para a rota <code>/users/{user_id}</code>. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m o usu\u00e1rio atualizado.</p> tests/test_app.py<pre><code>def test_update_user():\nresponse = client.put(\n'/users/1',\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\n</code></pre> <p>Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usu\u00e1rios. A \u00faltima opera\u00e7\u00e3o CRUD que precisamos implementar \u00e9 Delete.</p>"},{"location":"02/#implementando-a-rota-delete","title":"Implementando a Rota DELETE","text":"<p>A rota DELETE \u00e9 usada para excluir um usu\u00e1rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Delete\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> <p>Para transmitir uma mensagem de sucesso ou falha na opera\u00e7\u00e3o de exclus\u00e3o, podemos criar um modelo chamado <code>Message</code>. Esse modelo ser\u00e1 respons\u00e1vel por embalar uma mensagem que ser\u00e1 retornada na nossa API.</p> fast_zero/schemas.py<pre><code>class Message(BaseModel):\ndetail: str\n</code></pre> <p>Agora podemos criar nosso endpoint DELETE. Este endpoint receber\u00e1 o ID do usu\u00e1rio que queremos excluir. Note que, estamos lan\u00e7ando uma exce\u00e7\u00e3o HTTP quando o ID do usu\u00e1rio est\u00e1 fora do range da nossa lista (simula\u00e7\u00e3o do nosso banco de dados). Quando conseguimos excluir o usu\u00e1rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo <code>Message</code>.</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message\n# ...\n@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int):\nif user_id &gt; len(database) or user_id &lt; 1:\nraise HTTPException(status_code=404, detail='User not found')\ndel database[user_id - 1]\nreturn {'detail': 'User deleted'}\n</code></pre> <p>Com a implementa\u00e7\u00e3o da rota DELETE conclu\u00edda, \u00e9 fundamental garantirmos que essa rota est\u00e1 funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.</p>"},{"location":"02/#implementados-os-testes-para-rota-de-delte","title":"Implementados os testes para rota de DELTE","text":"<p>Nosso teste da rota DELETE precisa verificar se a exclus\u00e3o de um usu\u00e1rio existente funciona corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m uma mensagem informando que o usu\u00e1rio foi exclu\u00eddo.</p> tests/test_app.py<pre><code>def test_delete_user():\nresponse = client.delete('/users/1')\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre>"},{"location":"02/#commit","title":"Commit","text":"<p>Ap\u00f3s toda essa jornada de aprendizado, constru\u00e7\u00e3o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares \u00e9 uma boa pr\u00e1tica, pois mant\u00e9m um hist\u00f3rico detalhado das altera\u00e7\u00f5es e facilita a volta a uma vers\u00e3o anterior do c\u00f3digo, se necess\u00e1rio.</p> <p>Primeiramente, vamos verificar as altera\u00e7\u00f5es feitas no projeto com o comando <code>git status</code>. Este comando nos mostrar\u00e1 todos os arquivos modificados que ainda n\u00e3o foram inclu\u00eddos em um commit.</p> <pre><code>$ git status\n</code></pre> <p>Em seguida, vamos adicionar todas as altera\u00e7\u00f5es para o pr\u00f3ximo commit. O comando <code>git add .</code> adiciona todas as altera\u00e7\u00f5es feitas em todos os arquivos do projeto.</p> <pre><code>$ git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit. Com o comando <code>git commit</code>, criamos uma nova entrada no hist\u00f3rico do nosso projeto. \u00c9 importante adicionar uma mensagem descritiva ao commit, para que outras pessoas (ou n\u00f3s mesmos, no futuro) possam entender o que foi alterado. Nesse caso, a mensagem do commit poderia ser \"Implementando rotas CRUD\".</p> <pre><code>$ git commit -m \"Implementando rotas CRUD\"\n</code></pre> <p>Por fim, enviamos nossas altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code>. Se voc\u00ea tiver v\u00e1rias branches, certifique-se de estar na branch correta antes de executar este comando.</p> <pre><code>$ git push\n</code></pre> <p>E pronto! As altera\u00e7\u00f5es est\u00e3o seguras no hist\u00f3rico do git, e podemos continuar com o pr\u00f3ximo passo do projeto.</p>"},{"location":"02/#conclusao","title":"Conclus\u00e3o","text":"<p>Com a implementa\u00e7\u00e3o bem-sucedida das rotas CRUD, demos um passo significativo na constru\u00e7\u00e3o de uma API robusta e funcional com FastAPI. Agora temos a capacidade de manipular usu\u00e1rios - criar, ler, atualizar e excluir - o que \u00e9 fundamental para muitos sistemas de informa\u00e7\u00e3o.</p> <p>O papel dos testes em cada etapa n\u00e3o pode ser subestimado. Testes n\u00e3o apenas nos ajudam a assegurar que nosso c\u00f3digo est\u00e1 funcionando como esperado, mas tamb\u00e9m nos permitem refinar nossas solu\u00e7\u00f5es e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a import\u00e2ncia de executar seus testes sempre que fizer uma altera\u00e7\u00e3o em seu c\u00f3digo!</p> <p>At\u00e9 aqui, no entanto, trabalhamos com um \"banco de dados\" provis\u00f3rio, na forma de uma lista Python, que \u00e9 vol\u00e1til e n\u00e3o persiste os dados de uma execu\u00e7\u00e3o do aplicativo para outra. Para nosso aplicativo ser \u00fatil em um cen\u00e1rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. \u00c9 a\u00ed que os bancos de dados entram.</p> <p>No pr\u00f3ximo t\u00f3pico, vamos explorar uma das partes mais cr\u00edticas de qualquer aplicativo - a conex\u00e3o e intera\u00e7\u00e3o com um banco de dados. Vamos aprender a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persist\u00eancia de nossos dados de usu\u00e1rio entre as sess\u00f5es do aplicativo.</p>"},{"location":"03/","title":"[OK] Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic","text":""},{"location":"03/#ok-configurando-o-banco-de-dados-e-gerenciando-migracoes-com-alembic","title":"[OK] Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao SQLAlchemy e Alembic</li> <li>Instalando SQLAlchemy e Alembic</li> <li>Configurando e criando o banco de dados</li> <li>Criando e localizando tabelas utilizando SQLAlchemy</li> <li>Testando a cria\u00e7\u00e3o de tabelas</li> <li>Gerenciando migra\u00e7\u00f5es do banco de dados com Alembic</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ol\u00e1 a todos! Se voc\u00ea est\u00e1 chegando agora, recomendamos verificar as aulas anteriores de nosso curso \"FastAPI do Zero: Criando um Projeto com Bancos de Dados, Testes e Deploy\". Hoje, vamos mergulhar no SQLAlchemy e no Alembic, e come\u00e7aremos a configurar nosso banco de dados.</p> <p>Antes de mergulharmos na instala\u00e7\u00e3o e configura\u00e7\u00e3o, vamos esclarecer alguns conceitos.</p>"},{"location":"03/#o-que-e-um-orm-e-por-que-usamos-um","title":"O que \u00e9 um ORM e por que usamos um?","text":"<p>ORM significa Mapeamento Objeto-Relacional. \u00c9 uma t\u00e9cnica de programa\u00e7\u00e3o que vincula (ou mapeia) objetos a registros de banco de dados. Em outras palavras, um ORM permite que voc\u00ea interaja com seu banco de dados, como se voc\u00ea estivesse trabalhando com objetos Python.</p> <p>O SQLAlchemy \u00e9 um exemplo de ORM. Ele permite que voc\u00ea trabalhe com bancos de dados SQL de maneira mais natural aos programadores Python. Em vez de escrever consultas SQL cruas, voc\u00ea pode usar m\u00e9todos e atributos Python para manipular seus registros de banco de dados.</p> <p>Mas por que usar\u00edamos um ORM? Aqui est\u00e3o algumas raz\u00f5es:</p> <ul> <li> <p>Abstra\u00e7\u00e3o de banco de dados: ORMs permitem que voc\u00ea mude de um tipo de banco de dados para outro com poucas altera\u00e7\u00f5es no c\u00f3digo.</p> </li> <li> <p>Seguran\u00e7a: ORMs geralmente lidam com escapar de consultas e prevenir inje\u00e7\u00f5es SQL, um tipo comum de vulnerabilidade de seguran\u00e7a.</p> </li> <li> <p>Efici\u00eancia no desenvolvimento: ORMs podem gerar automaticamente esquemas, realizar migra\u00e7\u00f5es e outras tarefas que seriam demoradas para fazer manualmente.</p> </li> </ul>"},{"location":"03/#configuracoes-de-ambiente-e-as-12-fatores","title":"Configura\u00e7\u00f5es de ambiente e as 12 fatores","text":"<p>Uma boa pr\u00e1tica no desenvolvimento de aplica\u00e7\u00f5es \u00e9 separar as configura\u00e7\u00f5es do c\u00f3digo. Configura\u00e7\u00f5es, como credenciais de banco de dados, s\u00e3o propensas a mudan\u00e7as entre ambientes diferentes (como desenvolvimento, teste e produ\u00e7\u00e3o). Mistur\u00e1-las com o c\u00f3digo pode tornar o processo de mudan\u00e7a entre esses ambientes complicado e propenso a erros.</p> <p>Al\u00e9m disso, expor credenciais de banco de dados e outras informa\u00e7\u00f5es sens\u00edveis no c\u00f3digo-fonte \u00e9 uma pr\u00e1tica de seguran\u00e7a ruim. Se esse c\u00f3digo fosse comprometido, essas informa\u00e7\u00f5es poderiam ser usadas para acessar e manipular seus recursos.</p> <p>Por isso, usaremos o <code>pydantic-settings</code> para gerenciar nossas configura\u00e7\u00f5es de ambiente. A biblioteca permite que voc\u00ea defina configura\u00e7\u00f5es em arquivos separados ou vari\u00e1veis de ambiente e acesse-as de uma maneira estruturada e segura em seu c\u00f3digo.</p> <p>Isso est\u00e1 alinhado com a metodologia dos 12 fatores, um conjunto de melhores pr\u00e1ticas para desenvolvimento de aplica\u00e7\u00f5es modernas. O terceiro fator, \"Config\", afirma que as configura\u00e7\u00f5es que variam entre os ambientes devem ser armazenadas no ambiente e n\u00e3o no c\u00f3digo.</p> <p>Agora que entendemos melhor esses conceitos, vamos come\u00e7ar instalando as bibliotecas que vamos usar. O primeiro passo \u00e9 instalar o SQLAlchemy, um ORM que nos permite trabalhar com bancos de dados SQL de maneira Pythonic. Al\u00e9m disso, o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados, funciona muito bem com o SQLAlchemy e nos ajudar\u00e1 a gerenciar as altera\u00e7\u00f5es do esquema do nosso banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add sqlalchemy\n</code></pre> <p>Al\u00e9m disso, para evitar a escrita de configura\u00e7\u00f5es do banco de dados diretamente no c\u00f3digo-fonte, usaremos o <code>pydantic-settings</code>. Este pacote nos permite gerenciar as configura\u00e7\u00f5es do nosso aplicativo de uma maneira mais segura e estruturada.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add pydantic-settings\n</code></pre> <p>Agora estamos prontos para mergulhar na configura\u00e7\u00e3o do nosso banco de dados! Vamos em frente.</p>"},{"location":"03/#definindo-os-modelos-de-dados-com-sqlalchemy","title":"Definindo os Modelos de Dados com SQLAlchemy","text":"<p>O primeiro passo \u00e9 definir nosso modelo de usu\u00e1rio. Um modelo de dados \u00e9 a representa\u00e7\u00e3o de como nossos dados ser\u00e3o armazenados no banco de dados. Neste caso, o modelo <code>User</code> representar\u00e1 a tabela <code>users</code> em nosso banco de dados.</p> <p>Vamos criar um novo arquivo <code>models.py</code> no diret\u00f3rio <code>fast_zero</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch fast_zero/models.py\n</code></pre> <p>Adicione o seguinte c\u00f3digo no arquivo <code>models.py</code>:</p> fast_zero/models.py<pre><code>from sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nclass Base(DeclarativeBase):\npass\nclass User(Base):\n__tablename__ = 'users'\nid: Mapped[int] = mapped_column(primary_key=True)\nusername: Mapped[str]\npassword: Mapped[str]\nemail: Mapped[str]\n</code></pre>"},{"location":"03/#escrevendo-os-testes-para-as-tabelas","title":"Escrevendo os Testes para as Tabelas","text":"<p>Ao desenvolver software, \u00e9 uma boa pr\u00e1tica criar testes para cada nova funcionalidade implementada. Neste caso, depois de criar nosso modelo de usu\u00e1rio, precisamos garantir que ele funcione como esperado. Para isso, vamos criar dois novos arquivos de teste, <code>conftest.py</code> e <code>test_db.py</code>.</p> <p>O arquivo <code>conftest.py</code> \u00e9 usado pelo pytest para definir prepara\u00e7\u00f5es necess\u00e1rias antes da execu\u00e7\u00e3o dos testes ou configura\u00e7\u00f5es comuns a v\u00e1rios testes. \u00c9 um lugar centralizado para as chamadas fixtures.</p> <p>J\u00e1 o arquivo <code>test_db.py</code> \u00e9 onde vamos escrever os testes para nosso modelo de usu\u00e1rio. Isso ajuda a garantir que nossas tabelas est\u00e3o sendo criadas corretamente e que podem armazenar e recuperar informa\u00e7\u00f5es conforme esperado.</p> <p>Para criar esses arquivos, execute o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch tests/test_db.py\ntouch tests/conftest.py\n</code></pre> <p>No arquivo <code>conftest.py</code>, vamos introduzir uma fixture aos nossos testes pytest chamada \"session\". As fixtures do pytest s\u00e3o fun\u00e7\u00f5es que s\u00e3o executadas antes de cada teste para fornecer um ambiente de teste consistente. Neste caso, a fixture \"session\" est\u00e1 criando uma nova inst\u00e2ncia do banco de dados SQLite em mem\u00f3ria para cada teste. Isso permite que cada teste funcione isoladamente, garantindo que eles n\u00e3o interfiram uns nos outros.</p> tests/conftest.py<pre><code>import pytest\nfrom sqlalchemy import create_engine, select\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\nfrom fast_zero.models import Base\n@pytest.fixture\ndef session():\nengine = create_engine(\n'sqlite:///:memory:',\nconnect_args={'check_same_thread': False},\npoolclass=StaticPool,\n)\nSession = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase.metadata.create_all(engine)\nyield Session()\nBase.metadata.drop_all(engine)\n</code></pre> <p>Agora, no arquivo <code>test_db.py</code>, vamos escrever um teste para a cria\u00e7\u00e3o de um usu\u00e1rio. Este teste adiciona um novo usu\u00e1rio ao banco de dados, faz commit das mudan\u00e7as, e depois verifica se o usu\u00e1rio foi devidamente criado consultando-o pelo nome de usu\u00e1rio. Se o usu\u00e1rio foi criado corretamente, o teste passa. Caso contr\u00e1rio, o teste falha, indicando que h\u00e1 algo errado com nossa fun\u00e7\u00e3o de cria\u00e7\u00e3o de usu\u00e1rio.</p> tests/test_db.py<pre><code>from sqlalchemy import select\nfrom fast_zero.models import User\ndef test_create_user(session):\nnew_user = User(username='alice', password='secret', email='teste@test')\nsession.add(new_user)\nsession.commit()\nuser = session.scalar(select(User).where(User.username == 'alice'))\nassert user.username == 'alice'\n</code></pre>"},{"location":"03/#executando-o-teste","title":"Executando o teste","text":"<p>A execu\u00e7\u00e3o de testes \u00e9 uma parte vital do desenvolvimento de qualquer aplica\u00e7\u00e3o. Os testes nos ajudam a identificar e corrigir problemas antes que eles se tornem mais s\u00e9rios. Eles tamb\u00e9m fornecem a confian\u00e7a de que nossas mudan\u00e7as n\u00e3o quebraram nenhuma funcionalidade existente. No nosso caso, vamos executar os testes para validar nossos modelos de usu\u00e1rio e garantir que eles estejam funcionando como esperado.</p> <p>Para executar os testes, digite o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_db.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           28      2    93%\nfast_zero/models.py        11      0   100%\nfast_zero/schemas.py       15      0   100%\n-------------------------------------------\nTOTAL                      54      2    96%\n</code></pre> <p>Neste caso, podemos ver que todos os nossos testes passaram com sucesso. Isso significa que nossa funcionalidade de cria\u00e7\u00e3o de usu\u00e1rio est\u00e1 funcionando corretamente e que nosso modelo de usu\u00e1rio est\u00e1 sendo corretamente persistido no banco de dados.</p> <p>Com nossos modelos e testes de banco de dados agora em ordem, estamos prontos para avan\u00e7ar para a pr\u00f3xima fase de configura\u00e7\u00e3o de nosso banco de dados e gerenciamento de migra\u00e7\u00f5es.</p>"},{"location":"03/#configuracao-do-ambiente-do-banco-de-dados","title":"Configura\u00e7\u00e3o do ambiente do banco de dados","text":"<p>Por fim, vamos configurar nosso banco de dados. Primeiro, vamos criar um novo arquivo chamado <code>settings.py</code> dentro do diret\u00f3rio <code>fast_zero</code>. Aqui, usaremos o Pydantic para criar uma classe <code>Settings</code> que ir\u00e1 pegar as configura\u00e7\u00f5es do nosso arquivo <code>.env</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch fast_zero/settings.py\n</code></pre> <p>No arquivo <code>settings.py</code>, a classe <code>Settings</code> \u00e9 definida como:</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\nclass Settings(BaseSettings):\nmodel_config = SettingsConfigDict(\nenv_file='.env', env_file_encoding='utf-8'\n)\nDATABASE_URL: str\n</code></pre> <p>Agora, vamos definir o <code>DATABASE_URL</code> no nosso arquivo de ambiente <code>.env</code>. Crie o arquivo na raiz do projeto e adicione a seguinte linha:</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\n</code></pre> <p>Com isso, quando a classe <code>Settings</code> for instanciada, ela ir\u00e1 automaticamente carregar as configura\u00e7\u00f5es do arquivo <code>.env</code>.</p> <p>Finalmente, adicione o arquivo de banco de dados, <code>database.db</code>, ao <code>.gitignore</code> para garantir que n\u00e3o seja inclu\u00eddo no controle de vers\u00e3o. Adicionar informa\u00e7\u00f5es sens\u00edveis ou arquivos bin\u00e1rios ao controle de vers\u00e3o \u00e9 geralmente considerado uma pr\u00e1tica ruim.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>echo 'database.db' &gt;&gt; .gitignore\n</code></pre>"},{"location":"03/#instalando-o-alembic-e-criando-a-primeira-migracao","title":"Instalando o Alembic e Criando a Primeira Migra\u00e7\u00e3o","text":"<p>Antes de avan\u00e7armos, \u00e9 importante entender o que s\u00e3o migra\u00e7\u00f5es de banco de dados e por que s\u00e3o \u00fateis. As migra\u00e7\u00f5es s\u00e3o uma maneira de fazer altera\u00e7\u00f5es ou atualiza\u00e7\u00f5es no banco de dados, como adicionar uma tabela ou uma coluna a uma tabela, ou alterar o tipo de dados de uma coluna. Elas s\u00e3o extremamente \u00fateis, pois nos permitem manter o controle de todas as altera\u00e7\u00f5es feitas no esquema do banco de dados ao longo do tempo. Elas tamb\u00e9m nos permitem reverter para uma vers\u00e3o anterior do esquema do banco de dados, se necess\u00e1rio.</p> <p>Agora, vamos come\u00e7ar instalando o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usaremos o Poetry para adicionar o Alembic ao nosso projeto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add alembic\n</code></pre> <p>Ap\u00f3s a instala\u00e7\u00e3o do Alembic, precisamos inici\u00e1-lo em nosso projeto. O comando de inicializa\u00e7\u00e3o criar\u00e1 um diret\u00f3rio <code>migrations</code> e um arquivo de configura\u00e7\u00e3o <code>alembic.ini</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic init migrations\n</code></pre> <p>Com isso, a estrutura do nosso projeto sofre algumas altera\u00e7\u00f5es e novos arquivos s\u00e3o criados:</p> <pre><code>.\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 fast_zero\n\u2502  \u251c\u2500\u2500 __init__.py\n\u2502  \u251c\u2500\u2500 app.py\n\u2502  \u251c\u2500\u2500 models.py\n\u2502  \u2514\u2500\u2500 schemas.py\n\u251c\u2500\u2500 migrations\n\u2502  \u251c\u2500\u2500 env.py\n\u2502  \u251c\u2500\u2500 README\n\u2502  \u251c\u2500\u2500 script.py.mako\n\u2502  \u2514\u2500\u2500 versions\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u251c\u2500\u2500 __init__.py\n   \u251c\u2500\u2500 conftest.py\n   \u251c\u2500\u2500 test_app.py\n   \u2514\u2500\u2500 test_db.py\n</code></pre> <p>No arquivo <code>alembic.ini</code>: ficam as configura\u00e7\u00f5es gerais das nossas migra\u00e7\u00f5es. Na pasta <code>migrate</code> foram criados um arquivo chamado <code>env.py</code>, esse arquivo \u00e9 respons\u00e1vel por como as migra\u00e7\u00f5es ser\u00e3o feitas e o arquivo <code>script.py.mako</code> \u00e9 um template para as novas migra\u00e7\u00f5es.</p>"},{"location":"03/#criando-uma-migracao-automatica","title":"Criando uma migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Com o Alembic devidamente instalado e iniciado, agora \u00e9 o momento de gerar nossa primeira migra\u00e7\u00e3o. Mas, antes disso, precisamos garantir que o Alembic consiga acessar nossas configura\u00e7\u00f5es e modelos corretamente. Para isso, vamos fazer algumas altera\u00e7\u00f5es no arquivo <code>migrations/env.py</code>.</p> <p>Neste arquivo, precisamos:</p> <ol> <li>Importar as <code>Settings</code> do nosso arquivo <code>settings.py</code> e a <code>Base</code> dos nossos modelos.</li> <li>Configurar a URL do SQLAlchemy para ser a mesma que definimos em <code>Settings</code>.</li> <li>Verificar a exist\u00eancia do arquivo de configura\u00e7\u00e3o do Alembic e, se presente, l\u00ea-lo.</li> <li>Definir os metadados de destino como <code>Base.metadata</code>, que \u00e9 o que o Alembic utilizar\u00e1 para gerar automaticamente as migra\u00e7\u00f5es.</li> </ol> <p>O arquivo <code>migrations/env.py</code> modificado ficar\u00e1 assim:</p> migrations/env.py<pre><code>from alembic import context\nfrom fast_zero.settings import Settings\nfrom fast_zero.models import Base\nconfig = context.config\nconfig.set_main_option('sqlalchemy.url', Settings().DATABASE_URL)\nif config.config_file_name is not None:\nfileConfig(config.config_file_name)\ntarget_metadata = Base.metadata\n</code></pre> <p>Feitas essas altera\u00e7\u00f5es, estamos prontos para gerar nossa primeira migra\u00e7\u00e3o autom\u00e1tica. O Alembic \u00e9 capaz de gerar migra\u00e7\u00f5es a partir das mudan\u00e7as detectadas nos nossos modelos do SQLAlchemy.</p> <p>Para criar a migra\u00e7\u00e3o, utilizamos o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create users table\"\n</code></pre> <p>Este comando instrui o Alembic a criar uma nova revis\u00e3o de migra\u00e7\u00e3o no diret\u00f3rio <code>migrations/versions</code>. A revis\u00e3o gerada conter\u00e1 os comandos SQL necess\u00e1rios para aplicar a migra\u00e7\u00e3o (criar a tabela de usu\u00e1rios) e para reverter essa migra\u00e7\u00e3o, caso seja necess\u00e1rio.</p>"},{"location":"03/#analisando-a-migracao-automatica","title":"Analisando a migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Ao criar uma migra\u00e7\u00e3o autom\u00e1tica com o Alembic, um arquivo \u00e9 gerado dentro da pasta <code>migrations/versions</code>. O nome deste arquivo come\u00e7a com um ID de revis\u00e3o (um hash \u00fanico gerado pelo Alembic), seguido por uma breve descri\u00e7\u00e3o que fornecemos no momento da cria\u00e7\u00e3o da migra\u00e7\u00e3o, neste caso, <code>create_users_table</code>.</p> <p>Vamos analisar o arquivo de migra\u00e7\u00e3o:</p> migrations/versions/e018397cecf4_create_users_table.py<pre><code>\"\"\"create users table\nRevision ID: e018397cecf4\nRevises: \nCreate Date: 2023-07-13 03:43:03.730534\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n# revision identifiers, used by Alembic.\nrevision = 'e018397cecf4'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\ndef upgrade() -&gt; None:\n# ### commands auto generated by Alembic - please adjust! ###\nop.create_table('users',\nsa.Column('id', sa.Integer(), nullable=False),\nsa.Column('username', sa.String(), nullable=False),\nsa.Column('password', sa.String(), nullable=False),\nsa.Column('email', sa.String(), nullable=False),\nsa.PrimaryKeyConstraint('id')\n)\n# ### end Alembic commands ###\ndef downgrade() -&gt; None:\n# ### commands auto generated by Alembic - please adjust! ###\nop.drop_table('users')\n# ### end Alembic commands ###\n</code></pre> <p>Esse arquivo descreve as mudan\u00e7as a serem feitas no banco de dados. Ele usa a linguagem core do SQLAlchemy, que \u00e9 mais baixo n\u00edvel que o ORM. As fun\u00e7\u00f5es <code>upgrade</code> e <code>downgrade</code> definem, respectivamente, o que fazer para aplicar e para desfazer a migra\u00e7\u00e3o. No nosso caso, a fun\u00e7\u00e3o <code>upgrade</code> cria a tabela 'users' com os campos que definimos em <code>fast_zero/models.py</code>e a fun\u00e7\u00e3o <code>downgrade</code> a remove.</p> <p>Apesar desta migra\u00e7\u00e3o ter sido criada, ela ainda n\u00e3o foi aplicada ao nosso banco de dados. No entanto, o Alembic j\u00e1 criou um arquivo <code>database.db</code>, conforme especificamos no arquivo <code>.env</code> e que foi lido pela classe <code>Settings</code> do Pydantic. Al\u00e9m disso, ele criou uma tabela <code>alembic_version</code> no banco de dados para controlar as vers\u00f5es das migra\u00e7\u00f5es que foram aplicadas.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db SQLite version 3.42.0 2023-05-16 12:36:15\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\nversion_num VARCHAR(32) NOT NULL, CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nsqlite&gt; .exit\n</code></pre> <p>Para aplicar as migra\u00e7\u00f5es, usamos o comando <code>upgrade</code> do CLI Alembic. O argumento <code>head</code> indica que queremos aplicar todas as migra\u00e7\u00f5es que ainda n\u00e3o foram aplicadas:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; e018397cecf4, create users table\n</code></pre> <p>Agora, se examinarmos nosso banco de dados novamente, veremos que a tabela users foi criada:</p> <pre><code>sqlite3 database.db SQLite version 3.42.0 2023-05-16 12:36:15\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\nversion_num VARCHAR(32) NOT NULL, CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nCREATE TABLE users (\nid INTEGER NOT NULL, username VARCHAR NOT NULL, password VARCHAR NOT NULL, email VARCHAR NOT NULL, PRIMARY KEY (id)\n);\nsqlite&gt; .exit\n</code></pre> <p>Finalmente, lembre-se de que todas essas mudan\u00e7as que fizemos s\u00f3 existem localmente no seu ambiente de trabalho at\u00e9 agora. Para que sejam compartilhadas com outras pessas, precisamos fazer commit dessas mudan\u00e7as no nosso sistema de controle de vers\u00e3o.</p>"},{"location":"03/#commit","title":"Commit","text":"<p>Primeiro, vamos verificar o status do nosso reposit\u00f3rio para ver as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\n</code></pre> <p>Voc\u00ea ver\u00e1 uma lista de arquivos que foram modificados ou adicionados. As altera\u00e7\u00f5es devem incluir os arquivos de migra\u00e7\u00e3o que criamos, bem como quaisquer altera\u00e7\u00f5es que fizemos em nossos arquivos de modelo e configura\u00e7\u00e3o.</p> <p>Em seguida, vamos adicionar todas as mudan\u00e7as ao pr\u00f3ximo commit:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit das nossas altera\u00e7\u00f5es. Vamos fornecer uma mensagem de commit que descreve as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git commit -m \"Adicionada a primeira migra\u00e7\u00e3o com Alembic. Criada tabela de usu\u00e1rios.\"\n</code></pre> <p>Finalmente, vamos enviar as mudan\u00e7as para o reposit\u00f3rio remoto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git push\n</code></pre> <p>E pronto! As mudan\u00e7as que fizemos foram salvas no hist\u00f3rico do Git e agora est\u00e3o dispon\u00edveis no git.</p>"},{"location":"03/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos passos significativos para preparar nosso projeto FastAPI para interagir com um banco de dados. Come\u00e7amos definindo nosso primeiro modelo de dados, o <code>User</code>, utilizando o SQLAlchemy. Al\u00e9m disso, em conformidade com as pr\u00e1ticas de Desenvolvimento Orientado por Testes (TDD), implementamos um teste para assegurar que a funcionalidade de cria\u00e7\u00e3o de um novo usu\u00e1rio no banco de dados esteja operando corretamente.</p> <p>Avan\u00e7amos para configurar o ambiente de desenvolvimento, onde estabelecemos um arquivo <code>.env</code> para armazenar nossa <code>DATABASE_URL</code> e ajustamos o SQLAlchemy para utilizar essa URL. Complementarmente, inclu\u00edmos o arquivo do banco de dados ao <code>.gitignore</code> para evitar que seja rastreado pelo controle de vers\u00e3o.</p> <p>Na \u00faltima parte desta aula, focamos na instala\u00e7\u00e3o e configura\u00e7\u00e3o do Alembic, uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usando o Alembic, criamos nossa primeira migra\u00e7\u00e3o que, automaticamente, gera o esquema do banco de dados a partir dos nossos modelos SQLAlchemy.</p> <p>Com esses passos, nosso projeto est\u00e1 bem encaminhado para come\u00e7ar a persistir dados. Na pr\u00f3xima aula, avan\u00e7aremos para a fase crucial de conectar o SQLAlchemy aos endpoints do nosso projeto. Isso permitir\u00e1 a realiza\u00e7\u00e3o de opera\u00e7\u00f5es de CRUD nos nossos usu\u00e1rios diretamente atrav\u00e9s da API.</p>"},{"location":"04/","title":"[OK] Integrando Banco de Dados a API","text":""},{"location":"04/#ok-integrando-banco-de-dados-a-api","title":"[OK] Integrando Banco de Dados a API","text":"<p>Objetivos dessa aula:</p> <ul> <li>Integrando SQLAlchemy \u00e0 nossa aplica\u00e7\u00e3o FastAPI</li> <li>Utilizando a fun\u00e7\u00e3o Depends para gerenciar depend\u00eancias</li> <li>Modificando endpoints para interagir com o banco de dados</li> <li>Testando os novos endpoints com Pytest e fixtures</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ap\u00f3s a cria\u00e7\u00e3o de nossos modelos e migra\u00e7\u00f5es na aula passada, chegou o momento de dar um passo significativo: integrar o banco de dados \u00e0 nossa aplica\u00e7\u00e3o FastAPI. Vamos deixar de lado o banco de dados fict\u00edcio que criamos anteriormente e mergulhar na implementa\u00e7\u00e3o de um banco de dados real e funcional.</p>"},{"location":"04/#integrando-sqlalchemy-a-nossa-aplicacao-fastapi","title":"Integrando SQLAlchemy \u00e0 Nossa Aplica\u00e7\u00e3o FastAPI","text":"<p>Para aqueles que n\u00e3o est\u00e3o familiarizados, o SQLAlchemy \u00e9 uma biblioteca Python que facilita a intera\u00e7\u00e3o com um banco de dados SQL. Ele faz isso oferecendo uma forma de trabalhar com bancos de dados que aproveita a facilidade e o poder do Python, ao mesmo tempo em que mant\u00e9m a efici\u00eancia e a flexibilidade dos bancos de dados SQL.</p> <p>Uma pe\u00e7a chave do SQLAlchemy \u00e9 o conceito de uma \"sess\u00e3o\". Se voc\u00ea \u00e9 novo no mundo dos bancos de dados, pode pensar na sess\u00e3o como um carrinho de compras virtual: conforme voc\u00ea navega pelo site (ou, neste caso, conforme seu c\u00f3digo executa), voc\u00ea pode adicionar ou remover itens desse carrinho. No entanto, nenhuma altera\u00e7\u00e3o \u00e9 realmente feita at\u00e9 que voc\u00ea decida finalizar a compra. No contexto do SQLAlchemy, \"finalizar a compra\" \u00e9 equivalente a fazer o commit das suas altera\u00e7\u00f5es.</p> <p>A sess\u00e3o no SQLAlchemy \u00e9 t\u00e3o poderosa que, na verdade, incorpora tr\u00eas padr\u00f5es de arquitetura importantes.</p> <ol> <li> <p>Mapa de Identidade: Imagine que voc\u00ea esteja comprando frutas em uma loja online. Cada fruta que voc\u00ea adiciona ao seu carrinho recebe um c\u00f3digo de barras \u00fanico, para que a loja saiba exatamente qual fruta voc\u00ea quer. O Mapa de Identidade no SQLAlchemy \u00e9 esse sistema de c\u00f3digo de barras: ele garante que cada objeto na sess\u00e3o seja \u00fanico e facilmente identific\u00e1vel.</p> </li> <li> <p>Reposit\u00f3rio: A sess\u00e3o tamb\u00e9m atua como um reposit\u00f3rio. Isso significa que ela \u00e9 como um porteiro: ela controla todas as comunica\u00e7\u00f5es entre o seu c\u00f3digo Python e o banco de dados. Todos os comandos que voc\u00ea deseja enviar para o banco de dados devem passar pela sess\u00e3o.</p> </li> <li> <p>Unidade de Trabalho: Finalmente, a sess\u00e3o age como uma unidade de trabalho. Isso significa que ela mant\u00e9m o controle de todas as altera\u00e7\u00f5es que voc\u00ea quer fazer no banco de dados. Se voc\u00ea adicionar uma fruta ao seu carrinho e depois mudar de ideia e remover, a sess\u00e3o lembrar\u00e1 de ambas as a\u00e7\u00f5es. Ent\u00e3o, quando voc\u00ea finalmente decidir finalizar a compra, ela enviar\u00e1 todas as suas altera\u00e7\u00f5es para o banco de dados de uma s\u00f3 vez.</p> </li> </ol> <p>Entender esses conceitos \u00e9 importante, pois nos ajuda a entender melhor como o SQLAlchemy funciona e como podemos us\u00e1-lo de forma mais eficaz. Agora que temos uma ideia do que \u00e9 uma sess\u00e3o, vamos configurar uma para nosso projeto.</p> <p>Para isso, criaremos a fun\u00e7\u00e3o <code>get_session</code> e tamb\u00e9m definiremos <code>Session</code> no arquivo <code>database.py</code>:</p> fast_zero/database.py<pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\nfrom fast_zero.settings import Settings\nengine = create_engine(Settings().DATABASE_URL)\ndef get_session():\nwith Session(engine) as session:\nyield session\n</code></pre>"},{"location":"04/#gerenciando-dependencias-com-fastapi","title":"Gerenciando Depend\u00eancias com FastAPI","text":"<p>Assim como a sess\u00e3o SQLAlchemy, que implementa v\u00e1rios padr\u00f5es arquiteturais importantes, FastAPI tamb\u00e9m usa um conceito de padr\u00e3o arquitetural chamado \"Inje\u00e7\u00e3o de Depend\u00eancia\". </p> <p>No mundo do desenvolvimento de software, uma \"depend\u00eancia\" \u00e9 um componente que um m\u00f3dulo de software precisa para realizar sua fun\u00e7\u00e3o. Imagine um m\u00f3dulo como uma f\u00e1brica e as depend\u00eancias como as partes ou mat\u00e9rias-primas que a f\u00e1brica precisa para produzir seus produtos. Em vez de a f\u00e1brica ter que buscar essas pe\u00e7as por conta pr\u00f3pria (o que seria ineficiente), elas s\u00e3o entregues \u00e0 f\u00e1brica, prontas para serem usadas. Este \u00e9 o conceito de Inje\u00e7\u00e3o de Depend\u00eancia.</p> <p>A Inje\u00e7\u00e3o de Depend\u00eancia permite que mantenhamos um baixo n\u00edvel de acoplamento entre diferentes m\u00f3dulos de um sistema. As depend\u00eancias entre os m\u00f3dulos n\u00e3o s\u00e3o definidas no c\u00f3digo, mas sim pela configura\u00e7\u00e3o de uma infraestrutura de software (container) que \u00e9 respons\u00e1vel por \"injetar\" em cada componente suas depend\u00eancias declaradas.</p> <p>Em termos pr\u00e1ticos, o que isso significa \u00e9 que, em vez de cada parte do nosso c\u00f3digo ter que criar suas pr\u00f3prias inst\u00e2ncias de classes ou servi\u00e7os de que depende (o que pode levar a duplica\u00e7\u00e3o de c\u00f3digo e tornar os testes mais dif\u00edceis), essas inst\u00e2ncias s\u00e3o criadas uma vez e depois injetadas onde s\u00e3o necess\u00e1rias.</p> <p>FastAPI fornece a fun\u00e7\u00e3o <code>Depends</code> para ajudar a declarar e gerenciar essas depend\u00eancias. \u00c9 uma maneira declarativa de dizer ao FastAPI: \"Antes de executar esta fun\u00e7\u00e3o, execute primeiro essa outra fun\u00e7\u00e3o e passe-me o resultado\". Isso \u00e9 especialmente \u00fatil quando temos opera\u00e7\u00f5es que precisam ser realizadas antes de cada request, como abrir uma sess\u00e3o de banco de dados. </p>"},{"location":"04/#modificando-o-endpoint-post-users","title":"Modificando o Endpoint POST /users","text":"<p>Agora que temos a nossa sess\u00e3o de banco de dados sendo gerenciada por meio do FastAPI e da inje\u00e7\u00e3o de depend\u00eancias, vamos atualizar nossos endpoints para que possam tirar proveito disso. Come\u00e7aremos com a rota de POST para a cria\u00e7\u00e3o de usu\u00e1rios. Ao inv\u00e9s de usarmos o banco de dados falso que criamos inicialmente, agora vamos fazer a inser\u00e7\u00e3o real dos usu\u00e1rios no nosso banco de dados.</p> <p>Para isso, vamos modificar o nosso endpoint da seguinte maneira:</p> fast_zero/app.py<pre><code>from fastapi import Depends, FastAPI, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.models import User\nfrom fast_zero.database import get_session\nfrom fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message\n# ...\n@app.post('/users/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\ndb_user = session.scalar(\nselect(User).where(User.username == user.username)\n)\nif db_user:\nraise HTTPException(\nstatus_code=400, detail='Username already registered'\n)\ndb_user = User(\nusername=user.username, password=user.password, email=user.email\n)\nsession.add(db_user)\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Nesse c\u00f3digo, a fun\u00e7\u00e3o <code>create_user</code> recebe um objeto do tipo <code>UserSchema</code> e uma sess\u00e3o SQLAlchemy, que \u00e9 injetada automaticamente pelo FastAPI usando o <code>Depends</code>. O c\u00f3digo verifica se j\u00e1 existe um usu\u00e1rio com o mesmo nome no banco de dados e, caso n\u00e3o exista, cria um novo usu\u00e1rio, adiciona-o \u00e0 sess\u00e3o e confirma a transa\u00e7\u00e3o.</p> <p>Ao executar nosso linter, ele ir\u00e1 apontar um erro informando que importamos UserDB mas nunca o usamos.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\nfast_zero/app.py:7:55: F401 [*] `fast_zero.schemas.UserDB` imported but unused\nFound 1 error.\n</code></pre> <p>Isso ocorre porque a rota POST era a \u00fanica que estava utilizando UserDB, e agora que modificamos esta rota, podemos remover UserDB dos nossos imports.</p>"},{"location":"04/#testando-o-endpoint-post-users-com-pytest-e-fixtures","title":"Testando o Endpoint POST /users com Pytest e Fixtures","text":"<p>Agora que nossa rota de POST est\u00e1 funcionando com o banco de dados real, precisamos atualizar nossos testes para refletir essa mudan\u00e7a. Como estamos usando a inje\u00e7\u00e3o de depend\u00eancias, precisamos tamb\u00e9m usar essa funcionalidade nos nossos testes para que possamos injetar a sess\u00e3o de banco de dados de teste.</p> <p>Vamos criar a nossa fixture <code>client</code> para substituir a fun\u00e7\u00e3o <code>get_session</code> que estamos injetando no endpoint pela sess\u00e3o do banco em mem\u00f3ria que j\u00e1 t\u00ednhamos definido para banco de dados.</p> tests/conftest.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\nfrom fast_zero.database import get_session\n# ...\n@pytest.fixture\ndef client(session):\ndef get_session_override():\nreturn session\nwith TestClient(app) as client:\napp.dependency_overrides[get_session] = get_session_override\nyield client\napp.dependency_overrides.clear()\n</code></pre> <p>Com isso, quando o FastAPI tentar injetar a sess\u00e3o em nossos endpoints, ele vai injetar a sess\u00e3o de teste que definimos, em vez da sess\u00e3o real. E como estamos usando um banco de dados em mem\u00f3ria para os testes, nossos testes n\u00e3o v\u00e3o interferir nos dados reais do nosso aplicativo.</p> tests/test_app.py<pre><code>def test_create_user(client):\nresponse = client.post(\n'/users',\njson={\n'username': 'alice',\n'email': 'alice@example.com',\n'password': 'secret',\n},\n)\nassert response.status_code == 201\nassert response.json() == {\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\n</code></pre> <p>Agora que temos a nossa fixture configurada, vamos atualizar o nosso teste <code>test_create_user</code> para usar o novo cliente de teste e verificar que o usu\u00e1rio est\u00e1 sendo realmente criado no banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users FAILED\n</code></pre> <p>Depois de realizar essas mudan\u00e7as, podemos executar nossos testes e verificar se est\u00e3o passando. Por\u00e9m, embora o teste <code>test_create_user</code> tenha passado, precisamos agora ajustar os outros endpoints para que eles tamb\u00e9m utilizem a nossa sess\u00e3o de banco de dados. Nos pr\u00f3ximos passos, vamos realizar essas modifica\u00e7\u00f5es para garantir que todo o nosso aplicativo esteja usando o banco de dados real.</p>"},{"location":"04/#modificando-o-endpoint-get-users","title":"Modificando o Endpoint GET /users","text":"<p>{dizer que agora vamos atualizar o nosso endpoint de GET para funcionar no modelo real do banco de dados}</p> fast_zero/app.py<pre><code>@app.get('/users/', response_model=UserList)\ndef read_users(\nskip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\nusers = session.scalars(select(User).offset(skip).limit(limit)).all()\nreturn {'users': users}\n</code></pre> <p>{explicar o que s\u00e3o as coisas que adicionamos como <code>offset</code> e <code>limit</code> e porque elas s\u00e3o importantes agora nesses casos}</p>"},{"location":"04/#testando-o-endpoint-get-users","title":"Testando o Endpoint GET /users","text":"<p>Com a mudan\u00e7a para o banco de dados real, nosso banco de dados de teste ser\u00e1 sempre resetado para cada teste. Portanto, n\u00e3o podemos mais executar o teste que t\u00ednhamos antes, pois n\u00e3o haver\u00e3o usu\u00e1rios no banco. Para verificar se o nosso endpoint est\u00e1 funcionando corretamente, vamos criar um novo teste que solicita uma lista de usu\u00e1rios de um banco vazio:</p> tests/test_app.py<pre><code>def test_read_users(client):\nresponse = client.get('/users')\nassert response.status_code == 200\nassert response.json() == {'users': []}\n</code></pre> <p>Agora que temos nosso novo teste, podemos execut\u00e1-lo para verificar se o nosso endpoint GET est\u00e1 funcionando corretamente. Com esse novo teste, a fun\u00e7\u00e3o <code>test_read_users</code> deve passar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Por\u00e9m, \u00e9 claro, queremos tamb\u00e9m testar o caso em que existem usu\u00e1rios no banco. Para isso, vamos criar uma nova fixture que cria um usu\u00e1rio em nosso banco de dados de teste.</p>"},{"location":"04/#criando-uma-fixture-para-user","title":"Criando uma fixture para User","text":"<p>Para criar essa fixture, vamos aproveitar a nossa fixture de sess\u00e3o do SQLAlchemy, e criar um novo usu\u00e1rio dentro dela:</p> tests/conftest.py<pre><code>from fast_zero.models import Base, User\n# ...\n@pytest.fixture\ndef user(session):\nuser = User(username='Teste', email='teste@test.com', password='testtest')\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nreturn user\n</code></pre> <p>Com essa fixture, sempre que precisarmos de um usu\u00e1rio em nossos testes, podemos simplesmente passar <code>user</code> como um argumento para nossos testes, e o Pytest se encarregar\u00e1 de criar um novo usu\u00e1rio para n\u00f3s.</p> <p>Agora podemos criar um novo teste para verificar se o nosso endpoint est\u00e1 retornando o usu\u00e1rio correto quando existe um usu\u00e1rio no banco:</p> tests/test_app.py<pre><code>from fast_zero.schemas import UserPublic\n# ...\ndef test_read_users_with_users(client, user):\nuser_schema = UserPublic.model_validate(user).model_dump()\nresponse = client.get('/users/')\nassert response.json() == {'users': [user_schema]}\n</code></pre> <p>Agora podemos rodar o nosso teste novamente e verificar se ele est\u00e1 passando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users FAILED\n</code></pre> <p>No entanto, mesmo que nosso c\u00f3digo pare\u00e7a correto, podemos encontrar um problema: o Pydantic n\u00e3o consegue converter diretamente nosso modelo SQLAlchemy para um modelo Pydantic. Vamos resolver isso agora.</p>"},{"location":"04/#integrando-o-schema-ao-model","title":"Integrando o Schema ao Model","text":"<p>{dizer que precisamos alterar o <code>UserPublic</code> que usamos no teste para que ele reconhe\u00e7a o ORM}</p> <p>Para resolver o problema de convers\u00e3o entre SQLAlchemy e Pydantic, precisamos atualizar o nosso esquema <code>UserPublic</code> para que ele possa reconhecer os modelos do SQLAlchemy. Para isso, vamos adicionar a <code>linha model_config = ConfigDict(from_attributes=True)</code> ao nosso esquema:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, EmailStr, ConfigDict\n# ...\nclass UserPublic(BaseModel):\nid: int\nusername: str\nemail: EmailStr\nmodel_config = ConfigDict(from_attributes=True)\n</code></pre> <p>Com essa mudan\u00e7a, nosso esquema Pydantic agora pode ser convertido a partir de um modelo SQLAlchemy. Agora podemos executar nosso teste novamente e verificar se ele est\u00e1 passando.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Agora que temos nosso endpoint GET funcionando corretamente e testado, podemos seguir para o endpoint PUT, e continuar com o processo de atualiza\u00e7\u00e3o dos nossos endpoints.</p>"},{"location":"04/#modificando-o-endpoint-put-users","title":"Modificando o Endpoint PUT /users","text":"<p>Agora, vamos modificar o endpoint PUT de forma semelhante ao que fizemos com os endpoints POST e GET:</p> fast_zero/app.py<pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\nuser_id: int, user: UserSchema, session: Session = Depends(get_session)\n):\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\ndb_user.username = user.username\ndb_user.password = user.password\ndb_user.email = user.email\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Semelhante ao que fizemos antes, estamos injetando a sess\u00e3o do SQLAlchemy em nosso endpoint e utilizando-a para buscar o usu\u00e1rio a ser atualizado. Se o usu\u00e1rio n\u00e3o for encontrado, retornamos um erro 404.</p>"},{"location":"04/#adicionando-o-teste-do-put","title":"Adicionando o teste do PUT","text":"<p>Tamb\u00e9m precisamos adicionar um teste para o nosso novo endpoint PUT:</p> tests/test_app.py<pre><code>def test_update_user(client, user):\nresponse = client.put(\n'/users/1',\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\n</code></pre>"},{"location":"04/#modificando-o-endpoint-delete-users","title":"Modificando o Endpoint DELETE /users","text":"<p>Em seguida, modificamos o endpoint DELETE da mesma maneira:</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\nsession.delete(db_user)\nsession.commit()\nreturn {'detail': 'User deleted'}\n</code></pre> <p>Neste caso, estamos novamente usando a sess\u00e3o do SQLAlchemy para encontrar o usu\u00e1rio a ser deletado e, em seguida, exclu\u00edmos esse usu\u00e1rio do banco de dados.</p>"},{"location":"04/#adicionando-testes-para-delete","title":"Adicionando testes para DELETE","text":"<p>Assim como para o endpoint PUT, precisamos adicionar um teste para o nosso endpoint DELETE:</p> tests/test_app.py<pre><code>def test_delete_user(client, user):\nresponse = client.delete('/users/1')\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre>"},{"location":"04/#cobertura-e-testes-nao-feitos","title":"Cobertura e testes n\u00e3o feitos","text":"<p>Com o banco de dados agora em funcionamento, podemos verificar a cobertura de c\u00f3digo do arquivo <code>fast_zero/app.py</code>. Se olharmos para a imagem abaixo, vemos que ainda h\u00e1 alguns casos que n\u00e3o testamos. Por exemplo, o que acontece quando tentamos atualizar ou excluir um usu\u00e1rio que n\u00e3o existe?</p> <p></p> <p>Esses tr\u00eas casos ficam como exerc\u00edcio para quem est\u00e1 acompanhando este curso. </p> <p>Al\u00e9m disso, n\u00e3o devemos esquecer de remover a implementa\u00e7\u00e3o do banco de dados falso <code>database = []</code> que usamos inicialmente e remover tamb\u00e9m as defini\u00e7\u00f5es de <code>TestClient</code> em <code>test_app.py</code> pois tudo est\u00e1 usando as fixtures agora!</p>"},{"location":"04/#commit","title":"Commit","text":"<p>Agora que terminamos a atualiza\u00e7\u00e3o dos nossos endpoints, vamos fazer o commit das nossas altera\u00e7\u00f5es. O processo \u00e9 o seguinte:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Atualizando endpoints para usar o banco de dados real\"\ngit push\n</code></pre> <p>Com isso, terminamos a atualiza\u00e7\u00e3o dos nossos endpoints para usar o nosso banco de dados real.</p>"},{"location":"04/#conclusao","title":"Conclus\u00e3o","text":"<p>Parab\u00e9ns por chegar ao final desta aula! Voc\u00ea deu um passo significativo no desenvolvimento de nossa aplica\u00e7\u00e3o, substituindo a implementa\u00e7\u00e3o do banco de dados falso pela integra\u00e7\u00e3o com um banco de dados real usando SQLAlchemy. Tamb\u00e9m vimos como ajustar os nossos testes para considerar essa nova realidade.</p> <p>Nesta aula, abordamos como modificar os endpoints para interagir com o banco de dados real e como utilizar a inje\u00e7\u00e3o de depend\u00eancias do FastAPI para gerenciar nossas sess\u00f5es do SQLAlchemy. Tamb\u00e9m discutimos a import\u00e2ncia dos testes para garantir que nossos endpoints est\u00e3o funcionando corretamente, e como as fixtures do Pytest podem nos auxiliar na prepara\u00e7\u00e3o do ambiente para esses testes.</p> <p>Tamb\u00e9m nos deparamos com situa\u00e7\u00f5es onde o Pydantic e o SQLAlchemy n\u00e3o interagem perfeitamente bem, e como solucionar esses casos.</p> <p>No final desta aula, voc\u00ea deve estar confort\u00e1vel em integrar um banco de dados real a uma aplica\u00e7\u00e3o FastAPI, saber como escrever testes robustos que levem em considera\u00e7\u00e3o a intera\u00e7\u00e3o com o banco de dados, e estar ciente de poss\u00edveis desafios ao trabalhar com Pydantic e SQLAlchemy juntos.</p>"},{"location":"05/","title":"[REV] Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":""},{"location":"05/#rev-autenticacao-e-autorizacao-com-jwt","title":"[REV] Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":"<p>Revis\u00e3o</p> <ul> <li>Explicar melhor o JWT</li> <li>Explicar melhor os modelos de entrada e resposta do token</li> </ul> <p>Objetivos da Aula:</p> <ul> <li>Implementar autentica\u00e7\u00e3o de usu\u00e1rios com JWT.</li> <li>Adicionar l\u00f3gica de autoriza\u00e7\u00e3o aos endpoints de atualiza\u00e7\u00e3o e dele\u00e7\u00e3o.</li> <li>Utilizar a biblioteca Bcrypt para encriptar as senhas dos usu\u00e1rios.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p>"},{"location":"05/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Nesta aula, vamos abordar dois aspectos cruciais de qualquer aplica\u00e7\u00e3o web: a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o. At\u00e9 agora, nossos usu\u00e1rios podem criar, ler, atualizar e deletar suas contas, mas qualquer pessoa pode fazer essas a\u00e7\u00f5es. N\u00e3o queremos que qualquer usu\u00e1rio possa deletar ou modificar a conta de outro usu\u00e1rio. Para evitar isso, vamos implementar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o.</p> <p>A autentica\u00e7\u00e3o \u00e9 o processo de verificar quem um usu\u00e1rio \u00e9, enquanto a autoriza\u00e7\u00e3o \u00e9 o processo de verificar o que ele tem permiss\u00e3o para fazer. Usaremos o JSON Web Token (JWT) para implementar a autentica\u00e7\u00e3o, e adicionaremos l\u00f3gica de autoriza\u00e7\u00e3o aos nossos endpoints.</p> <p>Al\u00e9m disso, at\u00e9 agora, estamos armazenando as senhas dos usu\u00e1rios como texto puro no banco de dados, o que \u00e9 uma pr\u00e1tica insegura. Vamos corrigir isso utilizando a biblioteca Bcrypt para encriptar as senhas.</p>"},{"location":"05/#o-que-e-um-jwt","title":"O que \u00e9 um JWT","text":"<p>Um JWT consiste em tr\u00eas partes:</p> <ol> <li>Header: cont\u00e9m o tipo de token (JWT) e o algoritmo de assinatura usado.</li> <li>Payload: cont\u00e9m as reivindica\u00e7\u00f5es, que s\u00e3o informa\u00e7\u00f5es sobre o usu\u00e1rio (como o ID do usu\u00e1rio) e outras informa\u00e7\u00f5es adicionais.</li> <li>Signature: usada para verificar que o remetente do token \u00e9 quem diz ser e para garantir que a mensagem n\u00e3o foi alterada ao longo do caminho.</li> </ol> <p>Essas tr\u00eas partes s\u00e3o separadas por pontos (.) e juntas formam um token JWT.</p>"},{"location":"05/#como-funciona-o-jwt","title":"Como funciona o JWT","text":"<p>Em uma aplica\u00e7\u00e3o web, o processo de autentica\u00e7\u00e3o geralmente funciona da seguinte maneira:</p> <ol> <li>O usu\u00e1rio envia suas credenciais (nome de usu\u00e1rio e senha) para o servidor.</li> <li>O servidor verifica as credenciais e, se estiverem corretas, gera um token JWT e o envia de volta ao cliente.</li> <li>Nas solicita\u00e7\u00f5es subsequentes, o cliente deve incluir esse token no cabe\u00e7alho de autoriza\u00e7\u00e3o de suas solicita\u00e7\u00f5es.</li> <li>Quando o servidor recebe uma solicita\u00e7\u00e3o com um token JWT, ele pode verificar a assinatura e se o token \u00e9 v\u00e1lido e n\u00e3o expirou, ele processa a solicita\u00e7\u00e3o.</li> </ol> <pre><code>sequenceDiagram\n  participant Cliente as Cliente\n  participant Servidor as Servidor\n  Cliente-&gt;&gt;Servidor: Envia credenciais (nome de usu\u00e1rio e senha)\n  Servidor-&gt;&gt;Cliente: Verifica as credenciais\n  Servidor-&gt;&gt;Cliente: Envia token JWT\n  Cliente-&gt;&gt;Servidor: Envia solicita\u00e7\u00e3o com token JWT no cabe\u00e7alho de autoriza\u00e7\u00e3o\n  Servidor-&gt;&gt;Cliente: Verifica o token JWT e processa a solicita\u00e7\u00e3o</code></pre> <p>Nos pr\u00f3ximos t\u00f3picos, vamos detalhar como podemos gerar e verificar tokens JWT em nossa aplica\u00e7\u00e3o FastAPI, bem como adicionar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o aos nossos endpoints.</p>"},{"location":"05/#gerando-tokens-jwt","title":"Gerando tokens JWT","text":"<p>Para gerar tokens JWT, precisamos de duas bibliotecas extras: <code>python-jose</code> e <code>passlib</code>. A primeira ser\u00e1 usada para a gera\u00e7\u00e3o do token, enquanto a segunda ser\u00e1 usada para criptografar as senhas dos usu\u00e1rios. Para instal\u00e1-las, execute o seguinte comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add python-jose[cryptography] passlib[bcrypt]\n</code></pre> <p>Agora, vamos criar uma fun\u00e7\u00e3o para gerar nossos tokens JWT. Vamos criar um novo arquivo para gerenciar a seguran\u00e7a <code>security.py</code>. Nesse arquivo vamos iniciar a gera\u00e7\u00e3o dos tokens:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom jose import jwt\nfrom passlib.context import CryptContext\nSECRET_KEY = 'your-secret-key'  # Isso \u00e9 privis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\npwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\ndef create_access_token(data: dict):\nto_encode = data.copy()\nexpire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\nto_encode.update({'exp': expire})\nencoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\nreturn encoded_jwt\n</code></pre> <p>A fun\u00e7\u00e3o <code>create_access_token</code> \u00e9 respons\u00e1vel por criar um novo token JWT que ser\u00e1 usado para autenticar o usu\u00e1rio. Ela recebe um dicion\u00e1rio de dados, adiciona um tempo de expira\u00e7\u00e3o ao token (baseado na constante <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>), e em seguida usa a biblioteca <code>jose</code> para codificar essas informa\u00e7\u00f5es em um token JWT, que \u00e9 ent\u00e3o retornado.</p> <p>Note que a constante <code>SECRET_KEY</code> \u00e9 usada para assinar o token, e o algoritmo <code>HS256</code> \u00e9 usado para a codifica\u00e7\u00e3o. Em um cen\u00e1rio de produ\u00e7\u00e3o, voc\u00ea deve manter a <code>SECRET_KEY</code> em um local seguro e n\u00e3o exp\u00f4-la em seu c\u00f3digo.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, vamos ver como podemos usar a biblioteca <code>passlib</code> para tratar as senhas dos usu\u00e1rios.</p>"},{"location":"05/#hashing-de-senhas","title":"Hashing de Senhas","text":"<p>Armazenar senhas em texto puro \u00e9 uma pr\u00e1tica de seguran\u00e7a extremamente perigosa. Em vez disso, \u00e9 uma pr\u00e1tica padr\u00e3o criptografar (\"hash\") as senhas antes de armazen\u00e1-las. Quando um usu\u00e1rio tenta se autenticar, a senha inserida \u00e9 criptografada novamente e comparada com a vers\u00e3o criptografada armazenada no banco de dados. Se as duas correspondem, o usu\u00e1rio \u00e9 autenticado.</p> <p>Vamos implementar essa funcionalidade usando a biblioteca <code>passlib</code>. Vamos criar duas fun\u00e7\u00f5es: uma para criar o hash da senha e outra para verificar se uma senha inserida corresponde ao hash armazenado. Adicione o seguinte c\u00f3digo ao arquivo <code>security.py</code>:</p> fast_zero/security.py<pre><code>def get_password_hash(password: str):\nreturn pwd_context.hash(password)\ndef verify_password(plain_password: str, hashed_password: str):\nreturn pwd_context.verify(plain_password, hashed_password)\n</code></pre> <p>A fun\u00e7\u00e3o <code>get_password_hash</code> recebe uma senha em texto puro como argumento e retorna uma vers\u00e3o criptografada dessa senha. A fun\u00e7\u00e3o <code>verify_password</code> recebe uma senha em texto puro e uma senha criptografada como argumentos, e verifica se a senha em texto puro, quando criptografada, corresponde \u00e0 senha criptografada. Ambas as fun\u00e7\u00f5es utilizam o objeto <code>pwd_context</code>, que definimos anteriormente usando a biblioteca <code>passlib</code>.</p> <p>Agora, quando um usu\u00e1rio se registra em nossa aplica\u00e7\u00e3o, devemos usar a fun\u00e7\u00e3o <code>get_password_hash</code> para armazenar uma vers\u00e3o criptografada da senha. Quando um usu\u00e1rio tenta se autenticar, devemos usar a fun\u00e7\u00e3o <code>verify_password</code> para verificar se a senha inserida corresponde \u00e0 senha armazenada.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, vamos modificar nossos endpoints para fazer uso dessas fun\u00e7\u00f5es.</p>"},{"location":"05/#modificando-os-endpoints-para-usar-a-autenticacao","title":"Modificando os Endpoints para Usar a Autentica\u00e7\u00e3o","text":"<p>Com as fun\u00e7\u00f5es de cria\u00e7\u00e3o de hash de senha e verifica\u00e7\u00e3o de senha em vigor, agora podemos atualizar nossos endpoints para usar essa nova funcionalidade de autentica\u00e7\u00e3o.</p> <p>Primeiro, vamos modificar a fun\u00e7\u00e3o <code>create_user</code> para criar um hash da senha antes de armazen\u00e1-la no banco de dados.</p> fast_zero/app.py<pre><code>from fast_zero.security import get_password_hash\n# ...\n@app.post('/users/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\ndb_user = session.scalar(select(User).where(User.email == user.email))\nif db_user:\nraise HTTPException(status_code=400, detail='Email already registered')\nhashed_password = get_password_hash(user.password)\ndb_user = User(\nemail=user.email,\nusername=user.username,\npassword=hashed_password,\n)\nsession.add(db_user)\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Nesse novo c\u00f3digo, estamos usando a fun\u00e7\u00e3o <code>get_password_hash</code> para criar um hash da senha antes de armazen\u00e1-la no banco de dados. Al\u00e9m disso, estamos armazenando o hash da senha, em vez da senha em texto plano, em nosso objeto <code>User</code>.</p>"},{"location":"05/#sobre-o-teste-da-post-users","title":"Sobre o teste da POST /users/","text":"<p>Por n\u00e3o validar o password, usando o retorno <code>UserPublic</code>, o teste j\u00e1 escrito deve passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n</code></pre>"},{"location":"05/#criando-um-endpoint-de-geracao-do-token","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Antes de criar o endpoint, precisamos criar um schema para o nosso token. Em um contexto JWT, <code>access_token</code> \u00e9 o pr\u00f3prio token que representa a sess\u00e3o do usu\u00e1rio e cont\u00e9m informa\u00e7\u00f5es sobre o usu\u00e1rio, enquanto <code>token_type</code> \u00e9 um tipo de autentica\u00e7\u00e3o que ser\u00e1 inclu\u00eddo no cabe\u00e7alho de autoriza\u00e7\u00e3o de cada solicita\u00e7\u00e3o. Em geral, o <code>token_type</code> para JWT \u00e9 \"bearer\".</p> fast_zero/schemas.py<pre><code>class Token(BaseModel):\naccess_token: str\ntoken_type: str\n</code></pre>"},{"location":"05/#utilizando-oauth2passwordrequestform","title":"Utilizando OAuth2PasswordRequestForm","text":"<p>A classe <code>OAuth2PasswordRequestForm</code> \u00e9 uma classe especial do FastAPI que gera automaticamente um formul\u00e1rio para solicitar o username (email neste caso) e a senha. Este formul\u00e1rio ser\u00e1 apresentado automaticamente no Swagger UI e Redoc, o que facilita a realiza\u00e7\u00e3o de testes de autentica\u00e7\u00e3o.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add python-multipart\n</code></pre>"},{"location":"05/#criando-um-endpoint-de-geracao-do-token_1","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Agora vamos criar o endpoint que ir\u00e1 autenticar o usu\u00e1rio e fornecer um token de acesso JWT. Este endpoint ir\u00e1 receber as informa\u00e7\u00f5es de login do usu\u00e1rio, verificar se as credenciais s\u00e3o v\u00e1lidas e, em caso afirmativo, retornar um token de acesso JWT.</p> fast_zero/app.py<pre><code>from fastapi.security import OAuth2PasswordRequestForm\nfrom fast_zero.schemas import Message, Token, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\ncreate_access_token,\nget_password_hash,\nverify_password,\n)\n# ...\n@app.post('/token', response_model=Token)\ndef login_for_access_token(\nform_data: OAuth2PasswordRequestForm = Depends(),\nsession: Session = Depends(get_session),\n):\nuser = session.scalar(select(User).where(User.email == form_data.username))\nif not user:\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\nif not verify_password(form_data.password, user.password):\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\naccess_token = create_access_token(data={'sub': user.email})\nreturn {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Esse endpoint recebe os dados do formul\u00e1rio atrav\u00e9s do <code>form_data</code> (que s\u00e3o injetados automaticamente gra\u00e7as ao <code>Depends()</code>) e tenta recuperar um usu\u00e1rio com o email fornecido. Se o usu\u00e1rio n\u00e3o for encontrado ou a senha n\u00e3o corresponder ao hash armazenado no banco de dados, uma exce\u00e7\u00e3o \u00e9 lan\u00e7ada. Caso contr\u00e1rio, um token de acesso \u00e9 criado usando o <code>create_access_token()</code> que criamos anteriormente e retornado como uma resposta.</p>"},{"location":"05/#testando-token","title":"Testando /token","text":"<p>Agora vamos escrever um teste para verificar se o nosso novo endpoint est\u00e1 funcionando corretamente.</p> tests/test_app.py<pre><code>def test_get_token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.password},\n)\ntoken = response.json()\nassert response.status_code == 200\nassert 'access_token' in token\nassert 'token_type' in token\n</code></pre> <p>Nesse teste, n\u00f3s enviamos uma requisi\u00e7\u00e3o POST para o endpoint \"/token\" com um username e uma senha v\u00e1lidos. Ent\u00e3o, n\u00f3s verificamos que a resposta cont\u00e9m um \"access_token\" e um \"token_type\", que s\u00e3o os campos que esperamos de um JWT v\u00e1lido.</p> <p>No entanto, h\u00e1 um problema. Agora que a senha est\u00e1 sendo criptografada, nosso teste falhar\u00e1:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para corrigir isso, precisamos garantir que a senha esteja sendo criptografada na fixture antes de ser salva:</p> tests/confitest.py<pre><code>from fast_zero.security import get_password_hash\n# ...\n@pytest.fixture\ndef user(session):\nuser = User(\nusername='Teste',\nemail='teste@test.com',\npassword=get_password_hash('testtest'),\n)\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nreturn user\n</code></pre> <p>Vamos rodar o teste novamente. No entanto, ainda teremos um problema. Agora s\u00f3 temos a vers\u00e3o criptografada da senha, que n\u00e3o \u00e9 \u00fatil para fazer o login, j\u00e1 que o login exige a senha em texto puro:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para resolver isso, faremos uma modifica\u00e7\u00e3o no objeto user (um monkey patch) para adicionar a senha em texto puro:</p> tests/confitest.py<pre><code>@pytest.fixture\ndef user(session):\npassword = 'testtest'\nuser = User(\nusername='Teste',\nemail='teste@test.com',\npassword=get_password_hash(password),\n)\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nuser.clean_password = 'testtest'\nreturn user\n</code></pre> <p>Monkey patching \u00e9 uma t\u00e9cnica em que modificamos ou estendemos o c\u00f3digo em tempo de execu\u00e7\u00e3o. Neste caso, estamos adicionando um novo atributo <code>clean_password</code> ao objeto user para armazenar a senha em texto puro.</p> <p>Agora, podemos alterar o teste para usar <code>clean_password</code>:</p> tests/test_app.py<pre><code>def test_get_token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\ntoken = response.json()\nassert response.status_code == 200\nassert 'access_token' in token\nassert 'token_type' in token\n</code></pre> <p>E agora todos os testes devem passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Isso conclui a parte de autentica\u00e7\u00e3o de nossa API. No pr\u00f3ximo passo, iremos implementar a autoriza\u00e7\u00e3o nos endpoints.</p>"},{"location":"05/#protegendo-os-endpoints","title":"Protegendo os Endpoints","text":"<p>Agora que temos uma forma de autenticar nossos usu\u00e1rios e emitir tokens JWT, \u00e9 hora de usar essa infraestrutura para proteger nossos endpoints. Neste passo, vamos adicionar autentica\u00e7\u00e3o aos endpoints PUT e DELETE.</p> <p>Para garantir que as informa\u00e7\u00f5es do usu\u00e1rio sejam extra\u00eddas corretamente do token JWT, precisamos de um schema especial, o <code>TokenData</code>. Esse schema ser\u00e1 utilizado para tipificar os dados extra\u00eddos do token JWT e garantir que temos um campo <code>username</code> que ser\u00e1 usado para identificar o usu\u00e1rio.</p> fast_zero/schemas.py<pre><code>class TokenData(BaseModel):\nusername: str | None = None\n</code></pre> <p>Nesse ponto, criaremos uma a fun\u00e7\u00e3o <code>get_current_user</code> que ser\u00e1 respons\u00e1vel por extrair o token JWT do header <code>Authorization</code> da requisi\u00e7\u00e3o, decodificar esse token, extrair as informa\u00e7\u00f5es do usu\u00e1rio e finalmente obter o usu\u00e1rio do banco de dados. Se qualquer um desses passos falhar, uma exce\u00e7\u00e3o ser\u00e1 lan\u00e7ada e a requisi\u00e7\u00e3o ser\u00e1 negada. Vamos cria-l\u00e1 no arquivo <code>security.py</code>:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import TokenData\n# ...\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\nasync def get_current_user(\nsession: Session = Depends(get_session),\ntoken: str = Depends(oauth2_scheme),\n):\ncredentials_exception = HTTPException(\nstatus_code=status.HTTP_401_UNAUTHORIZED,\ndetail='Could not validate credentials',\nheaders={'WWW-Authenticate': 'Bearer'},\n)\ntry:\npayload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\nusername: str = payload.get('sub')\nif not username:\nraise credentials_exception\ntoken_data = TokenData(username=username)\nexcept JWTError:\nraise credentials_exception\nuser = session.scalar(\nselect(User).where(User.email == token_data.username)\n)\nif user is None:\nraise credentials_exception\nreturn user\n</code></pre> <p>Primeiro, vamos aplicar a autentica\u00e7\u00e3o no endpoint PUT. Se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 400. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 atualizado normalmente.</p> fast_zero/app.py<pre><code>from fast_zero.security import (\ncreate_access_token,\nget_current_user,\nget_password_hash,\nverify_password,\n)\n# ...\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\nuser_id: int,\nuser: UserSchema,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\ndb_user.username = user.username\ndb_user.password = user.password\ndb_user.email = user.email\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Agora, vamos aplicar a autentica\u00e7\u00e3o no endpoint DELETE. Semelhante ao PUT, se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 400. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 deletado.</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(\nuser_id: int,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\nsession.delete(db_user)\nsession.commit()\nreturn {'detail': 'User deleted'}\n</code></pre> <p>Com essa nova depend\u00eancia, o FastAPI automaticamente garantir\u00e1 que um token de autentica\u00e7\u00e3o v\u00e1lido seja fornecido antes de permitir o acesso a esses endpoints. Se o token n\u00e3o for v\u00e1lido, ou se o usu\u00e1rio tentar modificar ou deletar um usu\u00e1rio diferente, um erro ser\u00e1 retornado.</p>"},{"location":"05/#atualizando-os-testes","title":"Atualizando os Testes","text":"<p>Os testes precisam ser atualizados para refletir essas mudan\u00e7as. Primeiro, precisamos criar uma nova fixture que gere um token para um usu\u00e1rio de teste.</p> tests/conftest.py<pre><code>@pytest.fixture\ndef token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\nreturn response.json()['access_token']\n</code></pre> <p>Agora, podemos atualizar os testes para o endpoint PUT e DELETE para incluir a autentica\u00e7\u00e3o.</p> tests/test_app.py<pre><code>def test_update_user(client, user, token):\nresponse = client.put(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\ndef test_delete_user(client, user, token):\nresponse = client.delete(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre> <p>Finalmente, podemos rodar todos os testes para garantir que tudo esteja funcionando corretamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Com essas altera\u00e7\u00f5es, nossos endpoints agora est\u00e3o seguramente protegidos pela autentica\u00e7\u00e3o. Apenas os usu\u00e1rios autenticados podem alterar ou deletar seus pr\u00f3prios dados. Isso traz uma camada adicional de seguran\u00e7a e integridade para o nosso aplicativo.</p>"},{"location":"05/#commit","title":"Commit","text":"<p>Depois de finalizar a prote\u00e7\u00e3o dos endpoints e atualizar os testes, \u00e9 hora de fazer commit das altera\u00e7\u00f5es. N\u00e3o se esque\u00e7a de revisar as altera\u00e7\u00f5es antes de fazer o commit.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\ngit add .\ngit commit -m \"Protege os endpoints PUT e DELETE com autentica\u00e7\u00e3o\"\n</code></pre>"},{"location":"05/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos um passo importante para aumentar a seguran\u00e7a da nossa API. Implementamos a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o para os endpoints PUT e DELETE, garantindo que apenas usu\u00e1rios autenticados possam alterar ou excluir seus pr\u00f3prios dados. Tamb\u00e9m atualizamos os testes para incluir a autentica\u00e7\u00e3o. Na pr\u00f3xima aula, continuaremos a expandir a funcionalidade da nossa API. At\u00e9 l\u00e1!</p>"},{"location":"06/","title":"[REV] Refatorando a Estrutura do Projeto","text":""},{"location":"06/#rev-refatorando-a-estrutura-do-projeto","title":"[REV] Refatorando a Estrutura do Projeto","text":"<p>REVIS\u00c3O</p> <ul> <li>Trazer o factory-boy para essa aula. Criar um arquivo <code>factories.py</code></li> <li>Fazer os testes de listagem de usu\u00e1rio usando uma factory para isso</li> <li>remover a abordagem do user e user2 chamarem factories diferentes!</li> </ul> testes/factories.py<pre><code>import factory\nimport factory.fuzzy\nfrom fast_zero.models import Todo, TodoState, User\nclass UserFactory(factory.Factory):\nclass Meta:\nmodel = User\nid = factory.Sequence(lambda n: n)\nusername = factory.Sequence(lambda n: f'test{n}')\nemail = factory.LazyAttribute(lambda obj: f'{obj.username}@test.com')\npassword = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')\n</code></pre> <p>o teste!</p> testes/test_users.py<pre><code>def test_read_users_with_users(session, client):\nusers = UserFactory.create_batch(10)\nsession.bulk_save_objects(users)\nsession.commit()\nusers_schema = [\nUserPublic.model_validate(user).model_dump() for user in users\n]\nresponse = client.get('/users/')\nassert response.json() == {'users': users_schema}\n</code></pre> <p>Objetivos da Aula:</p> <ul> <li>Reestruturar o projeto para facilitar sua manuten\u00e7\u00e3o</li> <li>Mover coisas de altentica\u00e7\u00e3o para um arquivo chamado <code>fast_zero/auth.py</code></li> <li>Deixando em <code>fast_zero/secutiry.py</code> somente as valida\u00e7\u00f5es de senha</li> <li>Remover constantes usados em c\u00f3digo (<code>SECRET_KEY</code>, <code>ALGORITHM</code> e <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>) usando a classe Settings do arquivo <code>fast_zero/settings/py</code> que j\u00e1 temos e movendo para vari\u00e1veis de ambiente no arquivo <code>.env</code></li> <li>Criar um router espec\u00edfico para as rotas de <code>/users/</code></li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ao longo da evolu\u00e7\u00e3o de um projeto, \u00e9 natural que sua estrutura inicial necessite de ajustes para manter a legibilidade, a facilidade de manuten\u00e7\u00e3o e a organiza\u00e7\u00e3o do c\u00f3digo. Nesta aula, faremos exatamente isso em nosso projeto FastAPI: vamos refatorar partes dele para melhorar sua estrutura e, em seguida, ampliar a cobertura de nossos testes para garantir que todos os cen\u00e1rios poss\u00edveis sejam tratados corretamente. Vamos come\u00e7ar!</p>"},{"location":"06/#criando-um-router","title":"Criando um Router","text":"<p>O FastAPI nos fornece um recurso \u00fatil chamado routers, que nos permite organizar e agrupar diferentes rotas em nossa aplica\u00e7\u00e3o. Em outras palavras, um router \u00e9 um \"subaplicativo\" FastAPI que pode ser montado em uma aplica\u00e7\u00e3o principal.</p> <p>Ao usar routers, podemos manter nosso c\u00f3digo mais organizado e leg\u00edvel, especialmente \u00e0 medida que nossa aplica\u00e7\u00e3o cresce e adicionamos mais rotas.</p> <p>Vamos come\u00e7ar criando uma nova estrutura de diret\u00f3rios dentro de fast_zero chamada <code>routes</code>, onde teremos um arquivo <code>users.py</code> que ser\u00e1 respons\u00e1vel por todas as rotas relacionadas a usu\u00e1rios. Isso nos ajudar\u00e1 a manter o c\u00f3digo relacionado aos usu\u00e1rios centralizado em um \u00fanico lugar.</p>"},{"location":"06/#criando-um-router-para-users","title":"Criando um router para Users","text":"fast_zero/routes/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\nget_current_user,\nget_password_hash,\n)\nrouter = APIRouter(prefix='/users')\n</code></pre> <p>Neste bloco de c\u00f3digo, criamos uma inst\u00e2ncia do APIRouter com o prefixo '/users'. Isso nos permitir\u00e1 definir as rotas relacionadas aos usu\u00e1rios neste router, em vez de no aplicativo principal. Agora, ao inv\u00e9s de usarmos @app, usaremos @router para definir nossas rotas.</p> fast_zero/routes/users.py<pre><code>@router.post('/', response_model=UserPublic, status_code=201)\n@router.get('/', response_model=UserList)\n@router.put('/{user_id}', response_model=UserPublic)\n@router.delete('/{user_id}', response_model=Message)\n</code></pre> <p>Gra\u00e7as ao uso do prefixo no router, podemos simplificar os paths de nossos endpoints. Por exemplo, em vez de definir o path como '/users/{user_id}', podemos simplesmente usar '/{user_id}'.</p> Exemplo do arquivo <code>fast_zero/routes/users.py</code> completo fast_zero/routes/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\nget_current_user,\nget_password_hash,\n)\nrouter = APIRouter(prefix='/users')\n@router.post('/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\ndb_user = session.scalar(select(User).where(User.email == user.email))\nif db_user:\nraise HTTPException(status_code=400, detail='Email already registered')\nhashed_password = get_password_hash(user.password)\ndb_user = User(\nemail=user.email,\nusername=user.username,\npassword=hashed_password,\n)\nsession.add(db_user)\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n@router.get('/', response_model=UserList)\ndef read_users(\nskip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\nusers = session.scalars(select(User).offset(skip).limit(limit)).all()\nreturn {'users': users}\n@router.put('/{user_id}', response_model=UserPublic)\ndef update_user(\nuser_id: int,\nuser: UserSchema,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\ndb_user.username = user.username\ndb_user.password = user.password\ndb_user.email = user.email\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n@router.delete('/{user_id}', response_model=Message)\ndef delete_user(\nuser_id: int,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\nsession.delete(db_user)\nsession.commit()\nreturn {'detail': 'User deleted'}\n</code></pre>"},{"location":"06/#criando-um-router-para-auth","title":"Criando um router para Auth","text":"<p>No momento, temos rotas para <code>/</code> e <code>/token</code> ainda no arquivo <code>fast_zero/app.py</code>. Vamos dar um passo adiante e criar um router separado para lidar com a autentica\u00e7\u00e3o. Desta forma, conseguiremos manter nosso arquivo principal (<code>app.py</code>) mais limpo e focado em sua responsabilidade principal que \u00e9 iniciar nossa aplica\u00e7\u00e3o. </p> <p>O router para autentica\u00e7\u00e3o ser\u00e1 criado no arquivo <code>fast_zero/routers/auth.py</code>. Veja como fazer:</p> fast_zero/routers/auth.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Token\nfrom fast_zero.security import create_access_token, verify_password\nrouter = APIRouter()\n@router.post('/token', response_model=Token)\ndef login_for_access_token(\nform_data: OAuth2PasswordRequestForm = Depends(),\nsession: Session = Depends(get_session),\n):\nuser = session.scalar(select(User).where(User.email == form_data.username))\nif not user:\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\nif not verify_password(form_data.password, user.password):\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\naccess_token = create_access_token(data={'sub': user.email})\nreturn {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Neste bloco de c\u00f3digo, n\u00f3s criamos um novo router que lidar\u00e1 exclusivamente com a rota de obten\u00e7\u00e3o de token (<code>/token</code>). O endpoint <code>login_for_access_token</code> \u00e9 definido exatamente da mesma maneira que antes, mas agora como parte deste router de autentica\u00e7\u00e3o. </p> <p>Essa estrutura oferece algumas vantagens. Em primeiro lugar, nosso c\u00f3digo se torna mais organizado e mais f\u00e1cil de manter. Em segundo lugar, a separa\u00e7\u00e3o de responsabilidades (o chamado princ\u00edpio SoC) torna o c\u00f3digo mais f\u00e1cil de entender e testar. Por fim, nos permite escalar nosso aplicativo de maneira mais eficaz, pois podemos facilmente adicionar mais routers conforme o projeto cresce.</p>"},{"location":"06/#plugando-as-rotas-em-app","title":"Plugando as rotas em app","text":"<p>O FastAPI oferece uma maneira f\u00e1cil e direta de incluir routers em nossa aplica\u00e7\u00e3o principal. Isso nos permite organizar nossos endpoints de maneira eficiente e manter nosso arquivo <code>app.py</code> focado apenas em suas responsabilidades principais.</p> <p>Para incluir os routers em nossa aplica\u00e7\u00e3o principal, precisamos import\u00e1-los e usar a fun\u00e7\u00e3o <code>include_router()</code>. Aqui est\u00e1 como o nosso arquivo <code>app.py</code> fica depois de incluir os routers:</p> fast_zero/fast_zero/app.py<pre><code>from fastapi import FastAPI\nfrom fast_zero.routes import auth, users\napp = FastAPI()\napp.include_router(users.router)\napp.include_router(auth.router)\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Como voc\u00ea pode ver, nosso arquivo <code>app.py</code> \u00e9 muito mais simples agora. Ele agora delega as rotas para os respectivos routers, mantendo o foco em iniciar nossa aplica\u00e7\u00e3o FastAPI.</p>"},{"location":"06/#executando-os-testes","title":"Executando os testes","text":"<p>Depois de refatorar nosso c\u00f3digo, \u00e9 crucial verificar se tudo ainda est\u00e1 funcionando como esperado. Para isso, executamos nossos testes novamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Como voc\u00ea pode ver, todos os testes passaram. Isso significa que as altera\u00e7\u00f5es que fizemos no nosso c\u00f3digo n\u00e3o afetaram o funcionamento do nosso aplicativo. O router manteve todos os endpoints nas mesmas rotas, garantindo a continuidade do comportamento esperado.</p> <p>Agora, para melhor alinhar nossos testes com a nova estrutura do nosso c\u00f3digo, devemos reorganizar os arquivos de teste de acordo. Ou seja, tamb\u00e9m devemos criar arquivos de teste espec\u00edficos para cada router, em vez de manter todos os testes no arquivo <code>tests/test_app.py</code>. Essa estrutura facilitar\u00e1 a manuten\u00e7\u00e3o e compreens\u00e3o dos testes \u00e0 medida que nossa aplica\u00e7\u00e3o cresce.</p>"},{"location":"06/#reestruturando-os-arquivos-de-testes","title":"Reestruturando os arquivos de testes","text":"<p>Agora que o nosso projeto foi reestruturado, \u00e9 importante manter a organiza\u00e7\u00e3o nos arquivos de teste tamb\u00e9m. Agora, temos 3 arquivos de teste diferentes: </p> <ul> <li><code>/tests/test_app.py</code>: Para testes relacionados ao aplicativo em geral</li> <li><code>/tests/test_auth.py</code>: Para testes relacionados \u00e0 autentica\u00e7\u00e3o e token</li> <li><code>/tests/test_users.py</code>: Para testes relacionados \u00e0s rotas de usu\u00e1rios</li> </ul> <p>Vamos adaptar os testes para se encaixarem nessa nova estrutura.</p>"},{"location":"06/#ajustando-os-testes-para-auth","title":"Ajustando os testes para Auth","text":"<p>Vamos come\u00e7ar criando o arquivo <code>/tests/test_auth.py</code>. Esse arquivo ser\u00e1 respons\u00e1vel por testar todas as funcionalidades relacionadas \u00e0 autentica\u00e7\u00e3o do usu\u00e1rio.</p> /tests/test_auth.py<pre><code>def test_get_token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\ntoken = response.json()\nassert response.status_code == 200\nassert 'access_token' in token\nassert 'token_type' in token\n</code></pre>"},{"location":"06/#ajustando-os-testes-para-user","title":"Ajustando os testes para User","text":"<p>Em seguida, vamos mover os testes relacionados ao usu\u00e1rio para o arquivo <code>/tests/test_users.py</code>.</p> /tests/test_users.py<pre><code>from fast_zero.schemas import UserPublic\ndef test_create_user(client):\nresponse = client.post(\n'/users/',\njson={\n'username': 'alice',\n'email': 'alice@example.com',\n'password': 'secret',\n},\n)\nassert response.status_code == 201\nassert response.json() == {\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\ndef test_read_users(client):\nresponse = client.get('/users/')\nassert response.status_code == 200\nassert response.json() == {'users': []}\ndef test_read_users_with_users(client, user):\nuser_schema = UserPublic.model_validate(user).model_dump()\nresponse = client.get('/users/')\nassert response.json() == {'users': [user_schema]}\ndef test_update_user(client, user, token):\nresponse = client.put(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\ndef test_delete_user(client, user, token):\nresponse = client.delete(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre> <p>Essa organiza\u00e7\u00e3o facilita a manuten\u00e7\u00e3o dos testes, tornando-os mais claros e alinhados com a estrutura do nosso projeto.</p>"},{"location":"06/#executando-os-testes_1","title":"Executando os testes","text":"<p>Ap\u00f3s essa reestrutura\u00e7\u00e3o, \u00e9 importante garantir que tudo ainda est\u00e1 funcionando corretamente. Vamos executar os testes novamente para confirmar isso.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Como podemos ver, todos os testes continuam passando com sucesso, mesmo ap\u00f3s terem sido movidos para arquivos diferentes. Isso \u00e9 uma confirma\u00e7\u00e3o de que nossa reestrutura\u00e7\u00e3o foi bem-sucedida e que nossa aplica\u00e7\u00e3o continua funcionando como esperado.</p>"},{"location":"06/#movendo-as-constantes-para-variaveis-de-ambiente","title":"Movendo as constantes para vari\u00e1veis de ambiente","text":"<p>Conforme mencionamos na aula sobre os 12 fatores, \u00e9 uma boa pr\u00e1tica manter as constantes que podem mudar dependendo do ambiente em vari\u00e1veis de ambiente. Isso torna o seu projeto mais seguro e modular, pois voc\u00ea pode alterar essas constantes sem ter que modificar o c\u00f3digo-fonte.</p> <p>Por exemplo, temos estas constantes em nosso m\u00f3dulo <code>security.py</code>:</p> <pre><code>SECRET_KEY = 'your-secret-key'  # Isso \u00e9 provis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n</code></pre> <p>Estes valores n\u00e3o devem estar diretamente no c\u00f3digo-fonte, ent\u00e3o vamos mov\u00ea-los para nossas vari\u00e1veis de ambiente e represent\u00e1-los na nossa classe <code>Settings</code>.</p>"},{"location":"06/#adicionando-as-constantes-a-settings","title":"Adicionando as constantes a Settings","text":"<p>J\u00e1 temos uma classe ideal para fazer isso em <code>zero_app/settings.py</code>. Vamos alterar essa classe para incluir estas constantes.</p> zero_app/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\nclass Settings(BaseSettings):\nmodel_config = SettingsConfigDict(\nenv_file='.env', env_file_encoding='utf-8'\n)\nDATABASE_URL: str\nSECRET_KEY: str\nALGORITHM: str\nACCESS_TOKEN_EXPIRE_MINUTES: int\n</code></pre> <p>Agora, precisamos adicionar estes valores ao nosso arquivo <code>.env</code>.</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\nSECRET_KEY=\"your-secret-key\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre> <p>Com isso, podemos alterar o nosso c\u00f3digo em <code>zero_app/security.py</code> para ler as constantes a partir da classe <code>Settings</code>.</p>"},{"location":"06/#removendo-as-constantes-do-codigo","title":"Removendo as constantes do c\u00f3digo","text":"<p>Primeiramente, vamos carregar as configura\u00e7\u00f5es da classe <code>Settings</code> no in\u00edcio do m\u00f3dulo <code>security.py</code>.</p> zero_app/security.py<pre><code>from fast_zero.settings import Settings\nsettings = Settings()\n</code></pre> <p>Com isso, todos os lugares onde as constantes eram usadas devem ser substitu\u00eddos por <code>settings.CONSTANTE</code>. Por exemplo, na fun\u00e7\u00e3o <code>create_access_token</code>, vamos alterar para usar as constantes da classe <code>Settings</code>:</p> zero_app/security.py<pre><code>def create_access_token(data: dict):\nto_encode = data.copy()\nexpire = datetime.utcnow() + timedelta(\nminutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n)\nto_encode.update({'exp': expire})\nencoded_jwt = jwt.encode(\nto_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM\n)\nreturn encoded_jwt\n</code></pre> <p>Desta forma, eliminamos todas as constantes do c\u00f3digo-fonte e passamos a usar as configura\u00e7\u00f5es a partir da classe <code>Settings</code>. Isso torna nosso c\u00f3digo mais seguro, pois as constantes sens\u00edveis, como a chave secreta, est\u00e3o agora seguras em nosso arquivo <code>.env</code>, e nosso c\u00f3digo fica mais modular, pois podemos facilmente alterar estas constantes simplesmente mudando os valores no arquivo <code>.env</code>. Al\u00e9m disso, essa abordagem facilita o gerenciamento de diferentes ambientes (como desenvolvimento, teste e produ\u00e7\u00e3o) pois cada ambiente pode ter seu pr\u00f3prio arquivo <code>.env</code> com suas configura\u00e7\u00f5es espec\u00edficas.</p>"},{"location":"06/#testando-se-tudo-funciona","title":"Testando se tudo funciona","text":"<p>Depois de todas essas mudan\u00e7as, \u00e9 muito importante garantir que tudo ainda est\u00e1 funcionando corretamente. Para isso, vamos rodar todos os testes que temos at\u00e9 agora.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se tudo estiver certo, todos os testes devem passar. Lembre-se de que a refatora\u00e7\u00e3o n\u00e3o deve alterar a funcionalidade do nosso c\u00f3digo - apenas torn\u00e1-lo mais f\u00e1cil de ler e manter.</p>"},{"location":"06/#commit","title":"Commit","text":"<p>Para finalizar, vamos criar um commit para registrar todas as altera\u00e7\u00f5es que fizemos na nossa aplica\u00e7\u00e3o. Como essa \u00e9 uma grande mudan\u00e7a que envolve reestruturar a forma como lidamos com as rotas e mover as constantes para vari\u00e1veis de ambiente, podemos usar uma mensagem de commit descritiva que explique todas as principais altera\u00e7\u00f5es:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Refatorando estrutura do projeto: Criado routers para Users e Auth; movido constantes para vari\u00e1veis de ambiente.\"\n</code></pre>"},{"location":"06/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, vimos como refatorar a estrutura do nosso projeto FastAPI para torn\u00e1-lo mais manuten\u00edvel. Organizamos nosso c\u00f3digo em diferentes arquivos e usamos o sistema de roteadores do FastAPI para separar diferentes partes da nossa API. Tamb\u00e9m mudamos algumas constantes para o arquivo de configura\u00e7\u00e3o, tornando nosso c\u00f3digo mais seguro e flex\u00edvel. Finalmente, atualizamos nossos testes para refletir a nova estrutura do projeto.</p> <p>Refatorar \u00e9 um processo cont\u00ednuo - sempre h\u00e1 espa\u00e7o para melhorias. No entanto, com a estrutura que estabelecemos hoje, estamos em uma boa posi\u00e7\u00e3o para continuar a expandir nossa API no futuro.</p> <p>Na pr\u00f3xima aula, vamos explorar mais sobre autentica\u00e7\u00e3o e como gerenciar tokens de acesso e de atualiza\u00e7\u00e3o em nossa API FastAPI. Fique ligado!</p>"},{"location":"07/","title":"[OK] Tornando o sistema de autentica\u00e7\u00e3o robusto","text":""},{"location":"07/#ok-tornando-o-sistema-de-autenticacao-robusto","title":"[OK] Tornando o sistema de autentica\u00e7\u00e3o robusto","text":"<p>Objetivos da Aula:</p> <ul> <li>Testar os casos de autentica\u00e7\u00e3o de forma correta</li> <li>Implementar o refresh do token</li> <li>Introduzir testes que param o tempo com <code>freezefun</code></li> <li>Introduzir gera\u00e7\u00e3o de modelos autom\u00e1tica com <code>factory-boy</code></li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Na aula de hoje, vamos aprofundar nosso sistema de autentica\u00e7\u00e3o. J\u00e1 vimos em aulas anteriores como criar um sistema de autentica\u00e7\u00e3o b\u00e1sico, mas h\u00e1 muitas \u00e1reas em que podemos torn\u00e1-lo mais robusto. Por exemplo, como podemos lidar com situa\u00e7\u00f5es em que as coisas d\u00e3o errado? Como podemos garantir que nosso sistema seja seguro mesmo em cen\u00e1rios adversos? Essas s\u00e3o algumas das quest\u00f5es que vamos explorar hoje.</p> <p>Vamos come\u00e7ar examinando mais de perto os testes para autentica\u00e7\u00e3o. At\u00e9 agora, s\u00f3 testamos os casos que d\u00e3o certo - ou seja, quando o usu\u00e1rio sempre existe. Mas \u00e9 igualmente importante testar o que acontece quando as coisas d\u00e3o errado. Afinal, n\u00e3o podemos simplesmente assumir que tudo sempre vai correr bem. Por isso, vamos aprender como testar esses casos negativos.</p> <p>Em seguida, vamos implementar um recurso importante em qualquer sistema de autentica\u00e7\u00e3o: o refresh do token. Isso nos permite manter a sess\u00e3o do usu\u00e1rio ativa, mesmo se o token original expirar.</p>"},{"location":"07/#testes-para-autenticacao","title":"Testes para autentica\u00e7\u00e3o","text":"<p>Antes de mergulharmos nos testes, vamos falar um pouco sobre por que eles s\u00e3o t\u00e3o importantes. Na programa\u00e7\u00e3o, \u00e9 f\u00e1cil cair na armadilha de pensar que, se algo funciona na maioria das vezes, ent\u00e3o est\u00e1 tudo bem. Mas a verdade \u00e9 que \u00e9 nos casos marginais que os bugs mais dif\u00edceis de encontrar e corrigir costumam se esconder.</p> <p>Por exemplo, o que acontece se tentarmos autenticar um usu\u00e1rio que n\u00e3o existe? Ou se tentarmos autenticar com as credenciais erradas? Se n\u00e3o testarmos esses cen\u00e1rios, podemos acabar com um sistema que parece funcionar na superf\u00edcie, mas que na verdade est\u00e1 cheio de falhas de seguran\u00e7a.</p> <p></p> <p>No c\u00f3digo apresentado, se observarmos atentamente, vemos que o erro <code>HTTPException(status_code=400, detail='Not enough permissions')</code> em <code>users.py</code> na rota <code>/{user_id}</code> n\u00e3o est\u00e1 sendo coberto por nossos testes. Essa exce\u00e7\u00e3o \u00e9 lan\u00e7ada quando um usu\u00e1rio n\u00e3o autenticado ou um usu\u00e1rio sem permiss\u00f5es adequadas tenta acessar ou alterar um recurso que n\u00e3o deveria.</p> <p>Essa lacuna em nossos testes representa um risco potencial, pois n\u00e3o estamos verificando como nosso sistema se comporta quando algu\u00e9m tenta, por exemplo, alterar os detalhes de um usu\u00e1rio sem ter permiss\u00f5es adequadas. Embora possamos assumir que nosso sistema se comportar\u00e1 corretamente, a falta de testes nos deixa sem uma confirma\u00e7\u00e3o concreta.</p>"},{"location":"07/#testando-a-alteracao-de-um-usuario-nao-autorizado","title":"Testando a altera\u00e7\u00e3o de um usu\u00e1rio n\u00e3o autorizado","text":"<p>Agora, vamos come\u00e7ar a escrever alguns testes para esses casos. Vamos come\u00e7ar com um cen\u00e1rio simples: o que acontece quando um usu\u00e1rio tenta alterar as informa\u00e7\u00f5es de outro usu\u00e1rio?</p> <p>Para testar isso, vamos criar um novo teste chamado test_update_user_with_wrong_user. </p> <p></p>tests/test_users.py<pre><code>def test_update_user_with_wrong_user(client, user, token):\nresponse = client.put(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 400\nassert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> Este teste vai simular um usu\u00e1rio tentando alterar as informa\u00e7\u00f5es de outro usu\u00e1rio. Se nosso sistema estiver funcionando corretamente, ele dever\u00e1 rejeitar essa tentativa e retornar um erro."},{"location":"07/#criando-modelos-por-demanda-com-factory-boy","title":"Criando modelos por demanda com factory-boy","text":"<p>Embora nosso teste esteja tecnicamente correto, ele ainda n\u00e3o vai funcionar corretamente porque atualmente s\u00f3 temos um usu\u00e1rio em nosso banco de dados de testes. Precisamos de uma maneira de criar m\u00faltiplos usu\u00e1rios de teste facilmente. \u00c9 a\u00ed que entra o <code>factory-boy</code>.</p> <p>O <code>factory-boy</code> \u00e9 uma biblioteca que nos permite criar objetos de modelo de teste de forma r\u00e1pida e f\u00e1cil. Com ele, podemos criar uma \"f\u00e1brica\" de usu\u00e1rios que produzir\u00e1 novos objetos de usu\u00e1rio sempre que precisarmos de um. Isso nos permite criar m\u00faltiplos usu\u00e1rios de teste com facilidade, o que \u00e9 perfeito para nosso cen\u00e1rio atual.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev factory-boy\n</code></pre> <p>Depois de instalar o <code>factory-boy</code>, podemos criar uma <code>UserFactory</code>. Esta f\u00e1brica ser\u00e1 respons\u00e1vel por criar novos objetos de usu\u00e1rio sempre que precisarmos de um para nossos testes.</p> <pre><code>import factory\n# ...\nclass UserFactory(factory.Factory):\nclass Meta:\nmodel = User\nid = factory.Sequence(lambda n: n)\nusername = factory.Sequence(lambda n: f'test{n}')\nemail = factory.LazyAttribute(lambda obj: f'{obj.username}@test.com')\npassword = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')\n</code></pre> <p>Finalmente, podemos usar essa nova f\u00e1brica para criar m\u00faltiplos usu\u00e1rios de teste. Para fazer isso, modificamos nossa fixture de usu\u00e1rio existente para usar a UserFactory. Agora, sempre que executarmos nossos testes, teremos dois usu\u00e1rios dispon\u00edveis para testar.</p> tests/conftest.py<pre><code>@pytest.fixture\ndef user(session):\npassword = 'testtest'\nuser = UserFactory(password=get_password_hash(password))\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nuser.clean_password = 'testtest'\nreturn user\n@pytest.fixture\ndef user2(session):\npassword = 'testtest'\nuser = UserFactory(password=get_password_hash(password))\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nuser.clean_password = 'testtest'\nreturn user\n</code></pre> <p>Com essa nova configura\u00e7\u00e3o, podemos finalmente testar o cen\u00e1rio de um usu\u00e1rio tentando alterar as informa\u00e7\u00f5es de outro usu\u00e1rio. E como voc\u00ea pode ver, nossos testes passaram com sucesso, o que indica que nosso sistema est\u00e1 lidando corretamente com essa situa\u00e7\u00e3o.</p> tests/test_users.py<pre><code>def test_update_user_with_wrong_user(client, user, user2, token):\nresponse = client.put(\nf'/users/{user2.id}',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 400\nassert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> <p>Com o teste implementado, vamos execut\u00e1-lo para ver se nosso sistema est\u00e1 protegido contra essa a\u00e7\u00e3o indevida:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se todos os testes passaram com sucesso, isso indica que nosso sistema est\u00e1 se comportando como esperado, inclusive no caso de tentativas indevidas de deletar um usu\u00e1rio.</p>"},{"location":"07/#testando-o-delete-com-o-usuario-errado","title":"Testando o DELETE com o usu\u00e1rio errado","text":"<p>Continuando nossos testes, agora vamos testar o que acontece quando tentamos deletar um usu\u00e1rio com um usu\u00e1rio errado.</p> <p>Talvez voc\u00ea esteja se perguntando, por que precisamos fazer isso? Bem, lembre-se de que a seguran\u00e7a \u00e9 uma parte crucial de qualquer sistema de autentica\u00e7\u00e3o. Precisamos garantir que um usu\u00e1rio n\u00e3o possa deletar a conta de outro usu\u00e1rio - apenas a pr\u00f3pria conta. Portanto, \u00e9 importante que testemos esse cen\u00e1rio para garantir que nosso sistema est\u00e1 seguro.</p> <p>Aqui est\u00e1 o teste que vamos usar:</p> tests/test_users.py<pre><code>def test_delete_user_wrong_user(client, user, user2, token):\nresponse = client.delete(\nf'/users/{user2.id}',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 400\nassert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> <p>Como voc\u00ea pode ver, esse teste tenta deletar o user2 usando o token do user. Se nosso sistema estiver funcionando corretamente, ele dever\u00e1 rejeitar essa tentativa e retornar um status 400 com uma mensagem de erro indicando que o usu\u00e1rio n\u00e3o tem permiss\u00f5es suficientes para realizar essa a\u00e7\u00e3o.</p> <p>Vamos executar esse teste agora e ver o que acontece:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_users.py::test_delete_user_wrong_user PASSED\n</code></pre> <p>\u00d3timo, nosso teste passou! Isso significa que nosso sistema est\u00e1 corretamente impedindo um usu\u00e1rio de deletar a conta de outro usu\u00e1rio.</p> <p>Agora que terminamos de testar a autoriza\u00e7\u00e3o, vamos passar para o pr\u00f3ximo desafio: testar tokens expirados. Lembre-se, em um sistema de autentica\u00e7\u00e3o robusto, um token deve expirar ap\u00f3s um certo per\u00edodo de tempo por motivos de seguran\u00e7a. Portanto, \u00e9 importante que testemos o que acontece quando tentamos usar um token expirado. Vamos ver isso na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"07/#testando-a-expiracao-do-token","title":"Testando a expira\u00e7\u00e3o do token","text":"<p>Continuando com nossos testes de autentica\u00e7\u00e3o, a pr\u00f3xima coisa que precisamos testar \u00e9 a expira\u00e7\u00e3o do token. Tokens de autentica\u00e7\u00e3o s\u00e3o normalmente projetados para expirar ap\u00f3s um certo per\u00edodo de tempo por motivos de seguran\u00e7a. Isso evita que algu\u00e9m que tenha obtido um token possa us\u00e1-lo indefinidamente se ele for roubado ou perdido. Portanto, \u00e9 importante que verifiquemos que nosso sistema esteja tratando corretamente a expira\u00e7\u00e3o dos tokens.</p> <p>Para realizar esse teste, vamos usar uma biblioteca chamada <code>freezegun</code>. <code>freezegun</code> \u00e9 uma biblioteca Python que nos permite controlar o tempo durante nossos testes, o que \u00e9 perfeito para testar a expira\u00e7\u00e3o do token.</p> <p>Primeiro, vamos precisar instalar a biblioteca:</p> <pre><code>poetry add --group dev freezegun\n</code></pre> <p>Agora vamos criar nosso teste. Vamos come\u00e7ar pegando um token para um usu\u00e1rio, congelando o tempo, esperando pelo tempo de expira\u00e7\u00e3o do token e, em seguida, tentando usar o token para acessar um endpoint que requer autentica\u00e7\u00e3o.</p> tests/test_users.py<pre><code>from freezegun import freeze_time\n@freeze_time('2023-07-14 12:00:00')\ndef test_token_expiry(client, user, token):\nwith freeze_time('2023-07-14 12:31:00'):\nresponse = client.delete(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 401\nassert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Lembre-se de que configuramos nosso token para expirar ap\u00f3s 30 minutos. Portanto, n\u00f3s avan\u00e7amos o tempo em 31 minutos para garantir que o token tenha expirado.</p> <p>Agora, vamos executar nosso teste e ver o que acontece:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_users.py::test_token_expiry PASSED\n</code></pre> <p>\u00d3timo, nosso teste passou! Isso confirma que nosso sistema est\u00e1 lidando corretamente com a expira\u00e7\u00e3o dos tokens.</p> <p>No entanto, ainda h\u00e1 uma coisa que precisamos implementar: a atualiza\u00e7\u00e3o de tokens. Atualmente, quando um token expira, o usu\u00e1rio teria que fazer login novamente para obter um novo token. Isso n\u00e3o \u00e9 uma \u00f3tima experi\u00eancia para o usu\u00e1rio. Em vez disso, gostar\u00edamos de oferecer a possibilidade de o usu\u00e1rio atualizar seu token quando ele estiver prestes a expirar. Vamos ver como fazer isso na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"07/#testando-o-usuario-nao-existente-e-senha-incorreta","title":"Testando o usu\u00e1rio n\u00e3o existente e senha incorreta","text":"<p>Na constru\u00e7\u00e3o de qualquer sistema de autentica\u00e7\u00e3o, \u00e9 crucial garantir que os casos de erro sejam tratados corretamente. Isso n\u00e3o s\u00f3 previne poss\u00edveis falhas de seguran\u00e7a, mas tamb\u00e9m permite fornecer feedback \u00fatil aos usu\u00e1rios.</p> <p>Em nossa implementa\u00e7\u00e3o atual, temos duas situa\u00e7\u00f5es espec\u00edficas que devem retornar um erro: quando um usu\u00e1rio inexistente tenta fazer login e quando uma senha incorreta \u00e9 fornecida. Vamos abordar esses casos de erro em nossos pr\u00f3ximos testes.</p> <p>Embora possa parecer redundante testar esses casos j\u00e1 que ambos resultam no mesmo erro, \u00e9 importante verificar que ambos os cen\u00e1rios est\u00e3o corretamente tratados. Isso nos permitir\u00e1 manter a robustez do nosso sistema conforme ele evolui e muda ao longo do tempo.</p>"},{"location":"07/#testando-a-excecao-para-um-usuario-inexistente","title":"Testando a exce\u00e7\u00e3o para um usu\u00e1rio inexistente","text":"<p>Para este cen\u00e1rio, precisamos enviar um request para o endpoint de token com um e-mail que n\u00e3o existe no banco de dados. A resposta esperada \u00e9 um HTTP 400 com a mensagem de detalhe 'Incorrect email or password'.</p> tests/test_auth.py<pre><code>def test_token_inexistent_user(client):\nresponse = client.post(\n'/token',\ndata={'username': 'no_user@no_domain.com', 'password': 'testtest'},\n)\nassert response.status_code == 400\nassert response.json() == {'detail': 'Incorrect email or password'}\n</code></pre>"},{"location":"07/#testando-a-excecao-para-uma-senha-incorreta","title":"Testando a exce\u00e7\u00e3o para uma senha incorreta","text":"<p>Aqui, precisamos enviar um request para o endpoint de token com uma senha incorreta para um usu\u00e1rio existente. A resposta esperada \u00e9 um HTTP 400 com a mensagem de detalhe 'Incorrect email or password'.</p> tests/test_auth.py<pre><code>def test_token_wrong_password(client, user):\nresponse = client.post(\n'/token', data={'username': user.email, 'password': 'wrong_password'}\n)\nassert response.status_code == 400\nassert response.json() == {'detail': 'Incorrect email or password'}\n</code></pre> <p>Com esses testes, garantimos que nossas exce\u00e7\u00f5es est\u00e3o sendo lan\u00e7adas corretamente. Essa \u00e9 uma parte importante da constru\u00e7\u00e3o de um sistema de autentica\u00e7\u00e3o robusto, pois nos permite ter confian\u00e7a de que estamos tratando corretamente os casos de erro.</p>"},{"location":"07/#implementando-o-refresh-do-token","title":"Implementando o refresh do token","text":"<p>O processo de renova\u00e7\u00e3o de token \u00e9 uma parte essencial na implementa\u00e7\u00e3o de autentica\u00e7\u00e3o JWT. Em muitos sistemas, por raz\u00f5es de seguran\u00e7a, os tokens de acesso t\u00eam um tempo de vida relativamente curto. Isso significa que eles expiram ap\u00f3s um determinado per\u00edodo de tempo, e quando isso acontece, o cliente precisa obter um novo token para continuar acessando os recursos do servidor. Aqui \u00e9 onde o processo de renova\u00e7\u00e3o de token entra: permite que um cliente obtenha um novo token de acesso sem a necessidade de autentica\u00e7\u00e3o completa (por exemplo, sem ter que fornecer novamente o nome de usu\u00e1rio e senha).</p> <p>Agora vamos implementar a fun\u00e7\u00e3o de renova\u00e7\u00e3o de token em nosso c\u00f3digo.</p> fast_zero/routes/auth.py<pre><code>from fast_zero.security import (\ncreate_access_token,\nget_current_user,\nverify_password,\n)\n# ...\n@router.post('/refresh_token', response_model=Token)\ndef refresh_access_token(\nuser: User = Depends(get_current_user),\n):\nnew_access_token = create_access_token(data={'sub': user.email})\nreturn {'access_token': new_access_token, 'token_type': 'bearer'}\n</code></pre> <p>Vamos tamb\u00e9m implementar um teste para verificar se a fun\u00e7\u00e3o de renova\u00e7\u00e3o de token est\u00e1 funcionando corretamente.</p> tests/test_auth.py<pre><code>def test_refresh_token(client, user, token):\nresponse = client.post(\n'/refresh_token',\nheaders={'Authorization': f'Bearer {token}'},\n)\ndata = response.json()\nassert response.status_code == 200\nassert 'access_token' in data\nassert 'token_type' in data\nassert response.json()['token_type'] == 'bearer'\n</code></pre> <p>Ainda \u00e9 importante garantir que nosso sistema trate corretamente os tokens expirados. Para isso, vamos adicionar um teste que verifica se um token expirado n\u00e3o pode ser usado para renovar um token.</p> tests/test_auth.py<pre><code>def test_token_expiry(client, user):\nwith freeze_time('2023-07-14 12:00:00'):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\nassert response.status_code == 200\ntoken = response.json()['access_token']\nwith freeze_time('2023-07-14 13:00:00'):\nresponse = client.post(\n'/refresh_token',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 401\nassert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Agora, se executarmos nossos testes, todos eles devem passar, incluindo os novos testes que acabamos de adicionar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_auth.py::test_token_inexistent_user PASSED\ntests/test_auth.py::test_token_wrong_password PASSED\ntests/test_auth.py::test_refresh_token PASSED\ntests/test_auth.py::test_token_expiry PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user PASSED\ntests/test_users.py::test_delete_user_wrong_user PASSED\ntests/test_users.py::test_token_expiry PASSED\n</code></pre> <p>Com esses testes, podemos ter certeza de que cobrimos alguns casos importantes relacionados \u00e0 autentica\u00e7\u00e3o de usu\u00e1rios em nossa API.</p>"},{"location":"07/#commit","title":"Commit","text":"<p>Agora, vamos fazer um commit com as altera\u00e7\u00f5es que fizemos. </p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Implement refresh token and add relevant tests\"\n</code></pre>"},{"location":"07/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, abordamos uma grande quantidade de t\u00f3picos cruciais para a constru\u00e7\u00e3o de uma aplica\u00e7\u00e3o web segura e robusta. Come\u00e7amos com a implementa\u00e7\u00e3o da funcionalidade de renova\u00e7\u00e3o do token JWT, uma pe\u00e7a fundamental na arquitetura de autentica\u00e7\u00e3o baseada em token. Este processo garante que os usu\u00e1rios possam continuar acessando a aplica\u00e7\u00e3o, mesmo ap\u00f3s o token inicial ter expirado, sem a necessidade de fornecer suas credenciais novamente.</p> <p>Por\u00e9m, a implementa\u00e7\u00e3o do c\u00f3digo foi apenas a primeira parte do que fizemos. Uma parte significativa da nossa aula foi dedicada a testar de maneira exaustiva a nossa aplica\u00e7\u00e3o. Escrevemos testes para verificar o comportamento b\u00e1sico das nossas rotas de autentica\u00e7\u00e3o, mas n\u00e3o paramos por a\u00ed. Tamb\u00e9m consideramos v\u00e1rios casos de borda que podem surgir durante a autentica\u00e7\u00e3o de um usu\u00e1rio.</p> <p>Testamos, por exemplo, o que acontece quando se tenta obter um token com credenciais incorretas. Verificamos o comportamento da nossa aplica\u00e7\u00e3o quando um token expirado \u00e9 utilizado. Esses testes nos ajudam a garantir que nossa aplica\u00e7\u00e3o se comporte de maneira adequada n\u00e3o apenas nas situa\u00e7\u00f5es mais comuns, mas tamb\u00e9m quando algo sai do esperado.</p> <p>Al\u00e9m disso, ao implementar esses testes, n\u00f3s garantimos que futuras altera\u00e7\u00f5es no nosso c\u00f3digo n\u00e3o ir\u00e3o quebrar funcionalidades j\u00e1 existentes. Testes automatizados s\u00e3o uma parte fundamental de qualquer aplica\u00e7\u00e3o de alta qualidade, e o que fizemos hoje vai al\u00e9m do b\u00e1sico, mostrando como lidar com cen\u00e1rios complexos e realistas.</p> <p>A implementa\u00e7\u00e3o e os testes que fizemos hoje nos levam um passo adiante no desenvolvimento da nossa aplica\u00e7\u00e3o, deixando-a mais pr\u00f3xima de estar pronta para um ambiente de produ\u00e7\u00e3o.</p> <p>Na pr\u00f3xima aula, vamos utilizar a infraestrutura de autentica\u00e7\u00e3o que criamos hoje para permitir que os usu\u00e1rios criem, leiam, atualizem e deletem suas pr\u00f3prias listas de tarefas. Isso vai nos permitir explorar ainda mais as funcionalidades do FastAPI e do SQLAlchemy, al\u00e9m de continuar a expandir a nossa su\u00edte de testes. Esperamos ver voc\u00ea na pr\u00f3xima aula!</p>"},{"location":"08/","title":"[WIP] Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI","text":""},{"location":"08/#wip-criando-rotas-crud-para-gerenciamento-de-tarefas-em-fastapi","title":"[WIP] Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI","text":"<p>Objetivos da Aula:</p> <ul> <li>Cria\u00e7\u00e3o das rotas para as opera\u00e7\u00f5es CRUD das tarefas</li> <li>Fazer com s\u00f3 o usu\u00e1rio dono da tarefa possa acessar e modificar suas tarefas</li> <li>Escrita e execu\u00e7\u00e3o dos testes para cada opera\u00e7\u00e3o das tarefas</li> </ul> <p>Ol\u00e1 a todos! Estamos de volta com mais uma aula. Hoje vamos mergulhar na cria\u00e7\u00e3o das rotas CRUD para as nossas tarefas utilizando FastAPI. Essas opera\u00e7\u00f5es s\u00e3o fundamentais para qualquer aplica\u00e7\u00e3o de gerenciamento de tarefas e s\u00e3o o cora\u00e7\u00e3o do nosso sistema. Al\u00e9m disso, garantiremos que apenas o usu\u00e1rio que criou a tarefa possa acess\u00e1-la e modific\u00e1-la, garantindo a seguran\u00e7a e a privacidade dos dados. Vamos come\u00e7ar!</p>"},{"location":"08/#estrutura-inicial-do-codigo","title":"Estrutura inicial do c\u00f3digo","text":"<p>Primeiro, vamos criar um novo arquivo chamado <code>todos.py</code> dentro do diret\u00f3rio de <code>routes</code>:</p> fast_zero/routes/todos.py<pre><code>from fastapi import APIRouter\nrouter = APIRouter(prefix='/todos', tags=['todos'])\n</code></pre> <p>Neste c\u00f3digo, criamos uma nova inst\u00e2ncia da classe <code>APIRouter</code> do FastAPI. Esta classe \u00e9 usada para definir as rotas de nossa aplica\u00e7\u00e3o. A inst\u00e2ncia <code>router</code> funcionar\u00e1 como um mini aplicativo FastAPI, que poder\u00e1 ter suas pr\u00f3prias rotas, modelos de resposta, etc.</p> <p>A op\u00e7\u00e3o <code>prefix</code> no construtor do <code>APIRouter</code> \u00e9 usada para definir um prefixo comum para todas as rotas definidas neste roteador. Isso significa que todas as rotas que definirmos neste roteador come\u00e7ar\u00e3o com <code>/todos</code>. Usamos um prefixo aqui porque queremos agrupar todas as rotas relacionadas a tarefas em um lugar. Isso torna nossa aplica\u00e7\u00e3o mais organizada e f\u00e1cil de entender.</p> <p>A op\u00e7\u00e3o <code>tags</code> \u00e9 usada para agrupar as rotas em se\u00e7\u00f5es no documento interativo de API gerado pelo FastAPI (como Swagger UI e ReDoc). Todas as rotas que definirmos neste roteador aparecer\u00e3o na se\u00e7\u00e3o \"todos\" da documenta\u00e7\u00e3o da API.</p> <p>Depois de definir o roteador, precisamos inclu\u00ed-lo em nossa aplica\u00e7\u00e3o principal. Vamos atualizar o arquivo <code>fast_zero/app.py</code> para incluir as rotas de tarefas que iremos criar:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\nfrom fast_zero.routes import auth, todos, users\napp = FastAPI()\napp.include_router(users.router)\napp.include_router(auth.router)\napp.include_router(todos.router)\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Neste c\u00f3digo, chamamos o m\u00e9todo <code>include_router</code> do FastAPI para cada roteador que definimos. Este m\u00e9todo adiciona todas as rotas do roteador \u00e0 nossa aplica\u00e7\u00e3o. Com isso, nossa aplica\u00e7\u00e3o agora ter\u00e1 todas as rotas definidas nos roteadores <code>users</code>, <code>auth</code> e <code>todos</code>.</p>"},{"location":"08/#implementacao-da-tabela-no-banco-de-dados","title":"Implementa\u00e7\u00e3o da tabela no Banco de dados","text":"<p>Agora, iremos implementar a tabela 'Todos' no nosso banco de dados. Esta tabela estar\u00e1 diretamente relacionada \u00e0 tabela 'User', pois toda tarefa pertence a um usu\u00e1rio. Esta rela\u00e7\u00e3o \u00e9 crucial para garantir que s\u00f3 o usu\u00e1rio dono da tarefa possa acessar e modificar suas tarefas.</p> <pre><code>from enum import Enum\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\nclass TodoState(str, Enum):\ndraft = 'draft'\ntodo = 'todo'\ndoing = 'doing'\ndone = 'done'\ntrash = 'trash'\nclass Base(DeclarativeBase):\npass\nclass User(Base):\n__tablename__ = 'users'\nid: Mapped[int] = mapped_column(primary_key=True)\nusername: Mapped[str]\npassword: Mapped[str]\nemail: Mapped[str]\ntodos: Mapped[list['Todo']] = relationship(\nback_populates='user', cascade='all, delete-orphan'\n)\nclass Todo(Base):\n__tablename__ = 'todos'\nid: Mapped[int] = mapped_column(primary_key=True)\ntitle: Mapped[str]\ndescription: Mapped[str]\nstate: Mapped[TodoState]\nuser_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\nuser: Mapped[User] = relationship(back_populates='todos')\n</code></pre> <p>Neste ponto, \u00e9 importante compreender o conceito de <code>relationship</code> em SQLAlchemy. A fun\u00e7\u00e3o <code>relationship</code> define como as duas tabelas ir\u00e3o interagir. O argumento <code>back_populates</code> permite uma associa\u00e7\u00e3o bidirecional entre as tabelas, ou seja, se tivermos um usu\u00e1rio, podemos acessar suas tarefas atrav\u00e9s do atributo 'todos', e se tivermos uma tarefa, podemos encontrar o usu\u00e1rio a que ela pertence atrav\u00e9s do atributo 'user'. O argumento <code>cascade</code> determina o que ocorre com as tarefas quando o usu\u00e1rio associado a elas \u00e9 deletado. Ao definir 'all, delete-orphan', estamos instruindo o SQLAlchemy a deletar todas as tarefas de um usu\u00e1rio quando este for deletado.</p> <p>O uso do tipo Enum em <code>state: Mapped[TodoState]</code> \u00e9 outro ponto importante. Enum \u00e9 um tipo de dado especial que permite a cria\u00e7\u00e3o de um conjunto fixo de constantes. Neste caso, estamos utilizando para definir os poss\u00edveis estados de uma tarefa.</p> <p>Estes conceitos podem parecer um pouco complexos agora, mas ficar\u00e3o mais claros quando come\u00e7armos a implementar os testes.</p>"},{"location":"08/#testando-as-novas-implementacoes-do-banco-de-dados","title":"Testando as novas implementa\u00e7\u00f5es do banco de dados","text":"<p>Embora tenhamos 100% de cobertura de c\u00f3digo, isso n\u00e3o garante que tudo esteja funcionando corretamente. S\u00f3 implementamos a estrutura do banco de dados, mas n\u00e3o testamos a l\u00f3gica de como as tabelas e as rela\u00e7\u00f5es funcionam na pr\u00e1tica.</p> <p></p> <p>Para isso, criamos um teste para verificar se a rela\u00e7\u00e3o entre tarefas e usu\u00e1rios est\u00e1 funcionando corretamente. Este teste cria uma nova tarefa para um usu\u00e1rio e verifica se essa tarefa aparece na lista de tarefas desse usu\u00e1rio.</p> tests/test_db.py<pre><code>from fast_zero.models import Todo, User\n# ...\ndef test_create_todo(session: Session, user: User):\ntodo = Todo(\ntitle='Test Todo',\ndescription='Test Desc',\nstate='draft',\nuser_id=user.id,\n)\nsession.add(todo)\nsession.commit()\nsession.refresh(todo)\nuser = session.scalar(select(User).where(User.id == user.id))\nassert todo in user.todos\n</code></pre> <p>Com isso, voc\u00ea pode executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_db.py # ...\ntests/test_db.py::test_create_user_without_todos PASSED\ntests/test_db.py::test_create_todo PASSED\n</code></pre> <p>Isso mostra que os testes foram bem-sucedidos. Mesmo sem testes mais extensivos, agora vamos come\u00e7ar a criar os esquemas para esse modelo e, em seguida, os endpoints.</p>"},{"location":"08/#schemas-para-todos","title":"Schemas para Todos","text":"<p>Vamos criar dois esquemas para nosso modelo de tarefas (todos): <code>TodoSchema</code> e <code>TodoPublic</code>. </p> fast_zero/schemas.py<pre><code>from fast_zero.models import TodoState\n#...\nclass TodoSchema(BaseModel):\ntitle: str\ndescription: str\nstate: TodoState\nclass TodoPublic(BaseModel):\nid: int\ntitle: str\ndescription: str\nstate: TodoState\n</code></pre> <p><code>TodoSchema</code> ser\u00e1 usado para validar os dados de entrada quando uma nova tarefa \u00e9 criada e <code>TodoPublic</code> ser\u00e1 usado para validar os dados de sa\u00edda quando uma tarefa \u00e9 retornada em um endpoint.</p>"},{"location":"08/#endpoint-de-criacao","title":"Endpoint de cria\u00e7\u00e3o","text":"<p>Criamos o primeiro endpoint para a cria\u00e7\u00e3o de tarefas. Este \u00e9 um endpoint POST na rota '/todos'. \u00c9 importante destacar que, para criar uma tarefa, um usu\u00e1rio precisa estar autenticado e s\u00f3 esse usu\u00e1rio autenticado ser\u00e1 o propriet\u00e1rio da tarefa.</p> <pre><code>from typing import Annotated\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import Todo, User\nfrom fast_zero.schemas import TodoPublic, TodoSchema\nfrom fast_zero.security import get_current_user\nrouter = APIRouter()\nCurrentUser = Annotated[User, Depends(get_current_user)]\nrouter = APIRouter(prefix='/todos', tags=['todos'])\n@router.post('/', response_model=TodoPublic)\ndef create_todo(\ntodo: TodoSchema,\nuser: CurrentUser,\nsession: Session = Depends(get_session),\n):\ndb_todo: Todo = Todo(\ntitle=todo.title,\ndescription=todo.description,\nstate=todo.state,\nuser_id=user.id,\n)\nsession.add(db_todo)\nsession.commit()\nsession.refresh(db_todo)\nreturn db_todo\n</code></pre> <p>Neste endpoint, fazemos uso da depend\u00eancia <code>get_current_user</code> que garante que somente usu\u00e1rios autenticados possam criar tarefas, protegendo assim nossa aplica\u00e7\u00e3o.</p>"},{"location":"08/#testando-o-endpoint-de-criacao","title":"Testando o endpoint de cria\u00e7\u00e3o","text":"<p>Para garantir que nosso endpoint est\u00e1 funcionando corretamente, criamos um teste para ele. Este teste verifica se o endpoint '/todos' est\u00e1 criando tarefas corretamente.</p> tests/test_todos.py<pre><code>def test_create_todo(client, token):\nresponse = client.post(\n'/todos/',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'title': 'Test todo',\n'description': 'Test todo description',\n'state': 'draft',\n},\n)\nassert response.json() == {\n'id': 1,\n'title': 'Test todo',\n'description': 'Test todo description',\n'state': 'draft',\n}\n</code></pre> <p>No teste, fazemos uma requisi\u00e7\u00e3o POST para o endpoint '/todos' passando um token de autentica\u00e7\u00e3o v\u00e1lido e um JSON com os dados da tarefa a ser criada. Em seguida, verificamos se a resposta cont\u00e9m os dados corretos da tarefa criada.</p> <p>Para executar este teste, voc\u00ea deve usar o comando abaixo no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py # ...\ntests/test_todos.py::test_create_todo PASSED\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, os testes devem passar. Por\u00e9m, apesar do sucesso dos testes, nosso c\u00f3digo ainda n\u00e3o est\u00e1 completamente pronto. Ainda \u00e9 necess\u00e1rio criar uma migra\u00e7\u00e3o para a tabela de tarefas no banco de dados.</p>"},{"location":"08/#criando-a-migracao-da-nova-tabela","title":"Criando a migra\u00e7\u00e3o da nova tabela","text":"<p>Agora que temos nosso modelo de tarefas definido, precisamos criar uma migra\u00e7\u00e3o para adicionar a tabela de tarefas ao nosso banco de dados. Usamos o Alembic para criar e gerenciar nossas migra\u00e7\u00f5es. </p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create todos table\"\n# ...\nGenerating /&lt;caminho&gt;/fast_zero/migrations/versions/de865434f506_create_todos_table.py\n</code></pre> <p>Este comando gera um arquivo de migra\u00e7\u00e3o, que se parece com o c\u00f3digo abaixo:</p> migrations/versions/de865434f506_create_todos_table.py<pre><code>def upgrade() -&gt; None:\n# ### commands auto generated by Alembic - please adjust! ###\nop.create_table('todos',\nsa.Column('id', sa.Integer(), nullable=False),\nsa.Column('title', sa.String(), nullable=False),\nsa.Column('description', sa.String(), nullable=False),\nsa.Column('state', sa.Enum('draft', 'todo', 'doing', 'done', 'trash', name='todostate'), nullable=False),\nsa.Column('user_id', sa.Integer(), nullable=False),\nsa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\nsa.PrimaryKeyConstraint('id')\n)\n# ### end Alembic commands ###\ndef downgrade() -&gt; None:\n# ### commands auto generated by Alembic - please adjust! ###\nop.drop_table('todos')\n# ### end Alembic commands ###\n</code></pre> <p>Depois que a migra\u00e7\u00e3o for criada, precisamos aplic\u00e1-la ao nosso banco de dados. Execute o comando <code>alembic upgrade head</code> para aplicar a migra\u00e7\u00e3o.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade e018397cecf4 -&gt; de865434f506, create todos table\n</code></pre> <p>Agora que a migra\u00e7\u00e3o foi aplicada, nosso banco de dados deve ter uma nova tabela de tarefas. Para verificar, voc\u00ea pode abrir o banco de dados com o comando <code>sqlite3 database.db</code> e depois executar o comando <code>.schema</code> para ver o esquema do banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db # ...\nsqlite&gt; .schema\n# ...\nCREATE TABLE todos (\nid INTEGER NOT NULL, title VARCHAR NOT NULL, description VARCHAR NOT NULL, state VARCHAR(5) NOT NULL, user_id INTEGER NOT NULL, PRIMARY KEY (id), FOREIGN KEY(user_id) REFERENCES users (id)\n);\n</code></pre> <p>Finalmente, agora que temos a tabela de tarefas em nosso banco de dados, podemos testar nosso endpoint de cria\u00e7\u00e3o de tarefas no Swagger. Para fazer isso, execute nosso servidor FastAPI e abra o Swagger no seu navegador.</p>"},{"location":"08/#endpoint-de-listagem","title":"Endpoint de listagem","text":"<p>{aqui voc\u00ea deve criar um endpoint um pouco diferente. Al\u00e9m de offset e limit, precisamos fazer com que seja poss\u00edvel listar por t\u00edtulo, descri\u00e7\u00e3o ou status usando querystrings}</p>"},{"location":"08/#testes-para-esse-endpoint","title":"testes para esse endpoint","text":"<pre><code>def test_list_todos(client, token):\n# Create some todos\nfor i in range(5):\nclient.post(\n'/todos/',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'title': f'Test todo {i}',\n'description': f'Test todo description {i}',\n'state': 'draft',\n},\n)\n# Test list todos\nresponse = client.get(\n'/todos/',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert len(response.json()) == 5\ndef test_list_todos_pagination(client, token):\n# Test list todos with offset and limit\nresponse = client.get(\n'/todos/?offset=1&amp;limit=2',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert len(response.json()) == 2\ndef test_list_todos_filter_title(client, token):\n# Test list todos with title filter\nresponse = client.get(\n'/todos/?title=Test todo 1',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert len(response.json()) == 1\ndef test_list_todos_filter_description(client, token):\n# Test list todos with description filter\nresponse = client.get(\n'/todos/?description=Test todo description 2',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert len(response.json()) == 1\ndef test_list_todos_filter_state(client, token):\n# Test list todos with state filter\nresponse = client.get(\n'/todos/?state=draft',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert len(response.json()) == 5\n</code></pre>"},{"location":"08/#commit","title":"Commit","text":"<p>...</p>"},{"location":"08/#conclusao","title":"Conclus\u00e3o","text":"<p>...</p>"},{"location":"09/","title":"[OK] Dockerizando a nossa aplica\u00e7\u00e3o","text":""},{"location":"09/#ok-dockerizando-a-nossa-aplicacao","title":"[OK] Dockerizando a nossa aplica\u00e7\u00e3o","text":"<p>Objetivos da aula:</p> <ul> <li>Compreender os conceitos b\u00e1sicos do Docker</li> <li>Aprender o que \u00e9 um Dockerfile e sua estrutura</li> <li>Entender como criar uma imagem Docker para a nossa aplica\u00e7\u00e3o FastAPI</li> <li>Aprender a rodar a aplica\u00e7\u00e3o utilizando Docker</li> </ul> <p>Depois de implementar nosso gerenciador de tarefas na aula anterior, temos uma vers\u00e3o est\u00e1vel da nossa aplica\u00e7\u00e3o. Agora, vamos aprender como podemos \"dockerizar\" nossa aplica\u00e7\u00e3o FastAPI. Essa etapa \u00e9 crucial para garantir que nossa aplica\u00e7\u00e3o seja facilmente transport\u00e1vel e possa ser executada em qualquer ambiente sem problemas.</p>"},{"location":"09/#o-docker","title":"O Docker","text":"<p>Docker \u00e9 uma plataforma aberta que permite automatizar o processo de implanta\u00e7\u00e3o, escalonamento e opera\u00e7\u00e3o de aplica\u00e7\u00f5es dentro de cont\u00eaineres. Ele serve para \"empacotar\" uma aplica\u00e7\u00e3o e suas depend\u00eancias em um cont\u00eainer virtual que pode ser executado em qualquer sistema operacional que suporte Docker. Isso facilita a implanta\u00e7\u00e3o, o desenvolvimento e o compartilhamento de aplica\u00e7\u00f5es, al\u00e9m de proporcionar um ambiente isolado e consistente.</p>"},{"location":"09/#criando-nosso-dockerfile","title":"Criando nosso Dockerfile","text":"<p>O Dockerfile \u00e9 um arquivo de texto que cont\u00e9m todas as instru\u00e7\u00f5es para construir uma imagem Docker. Ele define o ambiente de execu\u00e7\u00e3o, os comandos necess\u00e1rios para preparar o ambiente e o comando a ser executado quando um cont\u00eainer \u00e9 iniciado a partir da imagem.</p> <p>Aqui est\u00e1 o nosso Dockerfile para a aplica\u00e7\u00e3o FastAPI:</p> <pre><code>FROM python:3.11-slim\nENV POETRY_VIRTUALENVS_CREATE=false\nRUN pip install poetry\n\nCOPY . .\n\nRUN poetry config installer.max-workers 10\nRUN poetry install --no-interaction --no-ansi\n\nEXPOSE 8000\nCMD [ \"poetry\", \"run\", \"uvicorn\", \"--host\", \"0.0.0.0\", \"fast_zero.app:app\" ]\n</code></pre> <p>Aqui est\u00e1 o que cada linha faz:</p> <ol> <li><code>FROM python:3.11-slim</code>: Define a imagem base para nosso cont\u00eainer. Estamos usando a vers\u00e3o slim da imagem do Python 3.11, que tem tudo que precisamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>ENV POETRY_VIRTUALENVS_CREATE=false</code>: Define uma vari\u00e1vel de ambiente que diz ao Poetry para n\u00e3o criar um ambiente virtual.</li> <li><code>RUN pip install poetry</code>: Instala o Poetry, nosso gerenciador de pacotes.</li> <li><code>COPY . .</code>: Copia todos os arquivos do diret\u00f3rio atual para o cont\u00eainer.</li> <li><code>RUN poetry config installer.max-workers 10</code>: Configura o Poetry para usar at\u00e9 10 workers ao instalar pacotes.</li> <li><code>RUN poetry install --no-interaction --no-ansi</code>: Instala as depend\u00eancias do nosso projeto sem intera\u00e7\u00e3o e sem cores no output.</li> <li><code>EXPOSE 8000</code>: Informa ao Docker que o cont\u00eainer vai escutar na porta 8000.</li> <li><code>CMD [ \"poetry\", \"run\", \"uvicorn\", \"--host\", \"0.0.0.0\", \"fast_zero.app:app\" ]</code>: Define o comando que ser\u00e1 executado quando o cont\u00eainer for iniciado. Neste caso, estamos iniciando nossa aplica\u00e7\u00e3o FastAPI usando Uvicorn.</li> </ol>"},{"location":"09/#criando-a-imagem","title":"Criando a imagem","text":"<p>Para criar uma imagem Docker a partir do Dockerfile, usamos o comando <code>docker build</code>. O comando a seguir cria uma imagem chamada \"fast_zero\":</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker build -t \"fast_zero\" .\n</code></pre> <p>Este comando l\u00ea o Dockerfile no diret\u00f3rio atual (indicado pelo <code>.</code>) e cria uma imagem chamada \"fast_zero\".</p>"},{"location":"09/#rodando-o-container","title":"Rodando o container","text":"<p>Para rodar o cont\u00eainer, usamos o comando <code>docker run</code>. O comando a seguir inicia um cont\u00eainer da imagem \"fast_zero\" e mapeia a porta 8000 do cont\u00eainer para a porta 8000 do host:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run fast_zero:latest -p 8000:8000\n</code></pre> <p>Este comando iniciar\u00e1 nossa aplica\u00e7\u00e3o dentro de um cont\u00eainer Docker, que estar\u00e1 escutando na porta 8000.</p>"},{"location":"09/#commit","title":"Commit","text":"<p>Ap\u00f3s criar o Dockerfile e testar a imagem Docker, podemos fazer o commit das altera\u00e7\u00f5es no Git:</p> <ol> <li>Adicione o Dockerfile e quaisquer outros arquivos modificados ao stage do Git com <code>git add .</code></li> <li>Fa\u00e7a o commit das altera\u00e7\u00f5es com <code>git commit -m \"Dockerize application\"</code></li> <li>Empurre as altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code></li> </ol>"},{"location":"09/#conclusao","title":"Conclus\u00e3o","text":"<p>Dockerizar nossa aplica\u00e7\u00e3o FastAPI permite que ela seja executada de forma consistente em qualquer ambiente, facilitando a implanta\u00e7\u00e3o e a distribui\u00e7\u00e3o. Na pr\u00f3xima aula, vamos aprender como podemos levar nossa aplica\u00e7\u00e3o para o pr\u00f3ximo n\u00edvel ao implant\u00e1-la em produ\u00e7\u00e3o usando o Fly.io.</p>"},{"location":"10/","title":"[OK] Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua","text":""},{"location":"10/#ok-automatizando-os-testes-com-integracao-continua","title":"[OK] Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua","text":"<p>Objetivos da aula:</p> <ul> <li>Compreender o conceito de Integra\u00e7\u00e3o Cont\u00ednua (CI)</li> <li>Familiarizar-se com a ferramenta GitHub Actions</li> <li>Aprender a configurar um pipeline de CI para testar a aplica\u00e7\u00e3o automaticamente</li> <li>Entender a import\u00e2ncia de uma cobertura de testes abrangente</li> <li>Conhecer a plataforma Codecov para monitoramento da cobertura de testes</li> </ul> <p>Na aula passada, preparamos nossa aplica\u00e7\u00e3o para execu\u00e7\u00e3o em containers Docker. Nesta aula, focaremos em garantir que nossa aplica\u00e7\u00e3o continue funcionando conforme o esperado a cada atualiza\u00e7\u00e3o de c\u00f3digo. Para isso, introduziremos o conceito de Integra\u00e7\u00e3o Cont\u00ednua (CI).</p>"},{"location":"10/#integracao-continua-ci","title":"Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":"<p>Integra\u00e7\u00e3o Cont\u00ednua (CI) \u00e9 uma pr\u00e1tica de desenvolvimento que envolve a integra\u00e7\u00e3o frequente de c\u00f3digo ao projeto principal. Com cada integra\u00e7\u00e3o - geralmente um commit - \u00e9 disparado um processo automatizado que constr\u00f3i e testa o c\u00f3digo. Isso permite detectar e corrigir problemas rapidamente, contribuindo para a manuten\u00e7\u00e3o da qualidade do software.</p>"},{"location":"10/#github-actions","title":"GitHub Actions","text":"<p>GitHub Actions \u00e9 um servi\u00e7o fornecido pelo GitHub que permite a automatiza\u00e7\u00e3o de workflows, incluindo a execu\u00e7\u00e3o de testes e implanta\u00e7\u00e3o de software, diretamente em seu reposit\u00f3rio GitHub. Cada tarefa \u00e9 definida como uma \"a\u00e7\u00e3o\", e a\u00e7\u00f5es podem ser combinadas para criar um \"workflow\" que atende a necessidades espec\u00edficas de desenvolvimento.</p>"},{"location":"10/#configurando-o-workflow-de-ci","title":"Configurando o workflow de CI","text":"<p>Vamos configurar um workflow de CI para nossa aplica\u00e7\u00e3o utilizando o GitHub Actions. Crie um novo arquivo em seu reposit\u00f3rio, sob o diret\u00f3rio <code>.github/workflows/</code>, e copie o seguinte c\u00f3digo:</p> .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\njobs:\ntest:\nruns-on: ubuntu-latest\nsteps:\n- name: Copia os arquivos do repo\nuses: actions/checkout@v3\n- name: Instalar o python\nuses: actions/setup-python@v4\nwith:\npython-version: '3.11.1'\n- name: Instalar Poetry\nrun: pip install poetry\n- name: Instalar depend\u00eancias do projeto\nrun: poetry install\n- name: Rodar os testes\nrun: poetry run task test --cov-report=xml\n- name: Subir cobertura para o codecov\nuses: codecov/codecov-action@v3\nwith:\ntoken: ${{ secrets.CODECOV_TOKEN }}\n</code></pre> <p>Vamos analisar este arquivo:</p> <ul> <li><code>name</code>: Define o nome do workflow.</li> <li><code>on</code>: Define os eventos que acionar\u00e3o o workflow (neste caso, push e pull requests).</li> <li><code>jobs</code>: Define os jobs que ser\u00e3o executados. Nesse caso, temos um job chamado \"test\".</li> <li><code>runs-on</code>: Define o ambiente em que o job ser\u00e1 executado (neste caso, a \u00faltima vers\u00e3o do Ubuntu).</li> <li><code>steps</code>: Define os passos do job:</li> <li><code>actions/checkout@v3</code>: Faz o checkout do reposit\u00f3rio.</li> <li><code>actions/setup-python@v4</code>: Instala a vers\u00e3o especificada do Python.</li> <li><code>pip install poetry</code>: Instala a ferramenta Poetry.</li> <li><code>poetry install</code>: Instala as depend\u00eancias do projeto.</li> <li><code>poetry run task test --cov-report=xml</code>: Executa os testes e gera um relat\u00f3rio de cobertura em formato xml.</li> <li><code>codecov/codecov-action@v3</code>: Faz o upload do relat\u00f3rio de cobertura para o Codecov. O token \u00e9 fornecido atrav\u00e9s de uma vari\u00e1vel de ambiente segura definida nas configura\u00e7\u00f5es do reposit\u00f3rio.</li> </ul>"},{"location":"10/#commit","title":"Commit","text":"<p>Ap\u00f3s adicionar e configurar o arquivo do workflow, voc\u00ea deve commitar as mudan\u00e7as em seu reposit\u00f3rio. Siga os passos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .github/workflows/pipeline.yaml\ngit commit -m \"Add CI pipeline\"\ngit push\n</code></pre>"},{"location":"10/#conclusao","title":"Conclus\u00e3o","text":"<p>A Integra\u00e7\u00e3o Cont\u00ednua \u00e9 uma pr\u00e1tica fundamental no desenvolvimento moderno de software, e o GitHub Actions \u00e9 uma ferramenta poderosa para implementar essa pr\u00e1tica. Ele n\u00e3o apenas ajuda a manter a qualidade do c\u00f3digo ao garantir que todos os testes sejam executados a cada commit, mas tamb\u00e9m permite detectar e corrigir problemas mais cedo no ciclo de desenvolvimento.</p> <p>Al\u00e9m disso, monitorar a cobertura de testes com o Codecov nos permite manter um alto padr\u00e3o de qualidade, garantindo que todas as partes do nosso c\u00f3digo sejam testadas.</p> <p>Na pr\u00f3xima aula, vamos levar nossa aplica\u00e7\u00e3o ao pr\u00f3ximo n\u00edvel, preparando-a para o deployment em produ\u00e7\u00e3o!</p>"},{"location":"11/","title":"[WIP] Fazendo deploy no Fly.io e configurando o PostgreSQL","text":""},{"location":"11/#wip-fazendo-deploy-no-flyio-e-configurando-o-postgresql","title":"[WIP] Fazendo deploy no Fly.io e configurando o PostgreSQL","text":"<p>Objetivos da aula:</p> <ul> <li>Entender o que \u00e9 o Fly.io e como instalar sua CLI</li> <li>Aprender a fazer o deploy de uma aplica\u00e7\u00e3o Docker no Fly.io</li> <li>Configurar uma inst\u00e2ncia do PostgreSQL no Fly.io</li> <li>Configurar as vari\u00e1veis de ambiente</li> <li>Rodar as migra\u00e7\u00f5es do Alembic</li> <li>Configurar o deploy cont\u00ednuo no Github Actions</li> </ul>"},{"location":"11/#o-flyio-e-a-instalacao-da-cli","title":"O Fly.io e a instala\u00e7\u00e3o da CLI","text":"<p>Na aula anterior, n\u00f3s automatizamos nossos testes e integramos tudo em um pipeline de integra\u00e7\u00e3o e deploy cont\u00ednuos. Agora, vamos aprender a fazer o deploy da nossa aplica\u00e7\u00e3o em um ambiente de produ\u00e7\u00e3o usando o Fly.io.</p> <p>O Fly.io \u00e9 uma plataforma de deploy que nos permite lan\u00e7ar nossas aplica\u00e7\u00f5es Docker na nuvem. Ele tamb\u00e9m fornece uma s\u00e9rie de recursos, como balanceamento de carga, cria\u00e7\u00e3o de inst\u00e2ncias de banco de dados e configura\u00e7\u00e3o de vari\u00e1veis de ambiente.</p> <p>Para iniciar, precisamos instalar a CLI do Fly.io, chamada <code>flyctl</code>. Voc\u00ea pode baix\u00e1-la no site oficial do Fly.io. Com o <code>flyctl</code> instalado, precisamos fazer login na nossa conta do Fly.io usando o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly auth login\n</code></pre> <p>Este comando ir\u00e1 abrir o navegador para voc\u00ea entrar com suas credenciais do Fly.io.</p>"},{"location":"11/#criando-a-aplicacao-no-flyio-e-fazendo-o-deploy","title":"Criando a aplica\u00e7\u00e3o no Fly.io e fazendo o deploy","text":"<p>Depois de logado, podemos criar uma nova aplica\u00e7\u00e3o no Fly.io usando o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly launch\n</code></pre> <p>Este comando ir\u00e1 perguntar algumas informa\u00e7\u00f5es sobre sua aplica\u00e7\u00e3o e ent\u00e3o criar\u00e1 uma nova aplica\u00e7\u00e3o no Fly.io. Com nossa aplica\u00e7\u00e3o criada, podemos agora fazer o deploy da nossa imagem Docker usando o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly deploy --local-only\n</code></pre> <p>A op\u00e7\u00e3o <code>--local-only</code> diz para o <code>flyctl</code> construir a imagem Docker localmente e depois fazer o upload dela para o Fly.io.</p>"},{"location":"11/#configurando-a-instancia-do-postgresql-no-flyio","title":"Configurando a inst\u00e2ncia do PostgreSQL no Fly.io","text":"<p>Agora, vamos criar uma inst\u00e2ncia do PostgreSQL. O Fly.io fornece um servi\u00e7o PostgreSQL que podemos usar para criar uma nova inst\u00e2ncia do PostgreSQL com apenas alguns comandos. </p>"},{"location":"11/#configurando-as-variaveis-de-ambiente-e-rodando-as-migracoes-do-alembic","title":"Configurando as vari\u00e1veis de ambiente e rodando as migra\u00e7\u00f5es do Alembic","text":"<p>Com a inst\u00e2ncia criada, algumas vari\u00e1veis de ambiente ser\u00e3o automaticamente definidas para n\u00f3s. Para que o Alembic possa executar as migra\u00e7\u00f5es, precisamos configurar a vari\u00e1vel <code>DATABASE_URL</code> no nosso aplicativo para apontar para a inst\u00e2ncia do PostgreSQL do Fly.io. </p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly secrets set DATABASE_URL=&lt;value&gt;\n</code></pre> <p>Substitua <code>&lt;value&gt;</code> pela string de conex\u00e3o do seu banco de dados PostgreSQL. </p> <p>Finalmente, podemos executar nossas migra\u00e7\u00f5es Alembic. Usaremos a CLI do Fly.io para executar o comando dentro de um cont\u00eainer do nosso aplicativo:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly ssh console --app &lt;your-app-name&gt; 'poetry run alembic upgrade head'\n</code></pre> <p>Substitua <code>&lt;your-app-name&gt;</code> pelo nome do seu aplicativo no Fly.io. </p>"},{"location":"11/#configurando-o-deploy-continuo-no-github-actions","title":"Configurando o deploy cont\u00ednuo no Github Actions","text":"<p>Agora que temos nosso aplicativo funcionando no Fly.io, podemos configurar o Github Actions para fazer o deploy autom\u00e1tico sempre que fizermos um push no nosso reposit\u00f3rio. Para isso, precisaremos adicionar alguns passos ao nosso arquivo de pipeline do Github Actions:</p> <pre><code>- name: Build and push Docker image to Fly.io\nrun: |\nflyctl deploy --local-only\nflyctl deploy\n</code></pre> <p>Com isso, nossa aplica\u00e7\u00e3o est\u00e1 pronta para uso no Fly.io!</p>"},{"location":"11/#conclusao","title":"Conclus\u00e3o","text":"<p>Ao longo desta aula, n\u00f3s mergulhamos no mundo do deploy de aplica\u00e7\u00f5es com o Fly.io, uma plataforma que facilita imensamente a tarefa de colocar nossas aplica\u00e7\u00f5es para funcionar na nuvem. Al\u00e9m disso, tamb\u00e9m tivemos a chance de entender como gerenciar vari\u00e1veis de ambiente de forma segura e eficiente, permitindo a nossa aplica\u00e7\u00e3o se adaptar a diferentes contextos de execu\u00e7\u00e3o.</p> <p>Aprendemos como subir nossa imagem Docker no Fly.io e como este processo pode ser simplificado e automatizado. Tamb\u00e9m vimos como \u00e9 poss\u00edvel ter nosso banco de dados rodando no mesmo ambiente da nossa aplica\u00e7\u00e3o, facilitando a manuten\u00e7\u00e3o e a escalabilidade.</p> <p>Configuramos e utilizamos o PostgreSQL no Fly.io, o que nos deu uma vis\u00e3o pr\u00e1tica de como gerenciar bancos de dados em um ambiente de produ\u00e7\u00e3o. Ao fazer isso, pudemos integrar ainda mais a nossa aplica\u00e7\u00e3o ao ambiente em que ela est\u00e1 rodando.</p> <p>Al\u00e9m disso, exploramos a import\u00e2ncia das migra\u00e7\u00f5es e como elas podem ser gerenciadas usando o Alembic, que nos permitiu atualizar nosso banco de dados de forma controlada e rastre\u00e1vel.</p> <p>Finalmente, vimos como podemos automatizar todo o processo de deploy usando o Github Actions. Esta \u00e9 uma pr\u00e1tica extremamente \u00fatil e poderosa, pois permite que a nossa aplica\u00e7\u00e3o esteja sempre atualizada com as \u00faltimas altera\u00e7\u00f5es que fizemos, sem a necessidade de qualquer interven\u00e7\u00e3o manual.</p> <p>Com todas essas pe\u00e7as, temos agora uma aplica\u00e7\u00e3o robusta e pronta para escalar, com todos os elementos necess\u00e1rios para ser operada em um ambiente de produ\u00e7\u00e3o real. Estas s\u00e3o ferramentas e pr\u00e1ticas que est\u00e3o no cora\u00e7\u00e3o do desenvolvimento de software moderno, e domin\u00e1-las nos permitir\u00e1 construir aplica\u00e7\u00f5es cada vez mais complexas e eficientes.</p> <p>Na pr\u00f3xima aula, faremos uma recapitula\u00e7\u00e3o de tudo o que aprendemos neste curso e discutiremos os pr\u00f3ximos passos. Continue acompanhando para fortalecer ainda mais seus conhecimentos em desenvolvimento de aplica\u00e7\u00f5es com FastAPI, Docker, CI/CD e muito mais. At\u00e9 a pr\u00f3xima aula!</p>"},{"location":"12/","title":"[WIP] Despedida","text":""},{"location":"12/#wip-despedida","title":"[WIP] Despedida","text":"<p>Objetivos da aula:</p> <ul> <li>Fazer uma revis\u00e3o geral dos conceitos e pr\u00e1ticas que abordamos ao longo do curso.</li> <li>Encorajar a explora\u00e7\u00e3o futura e o aprofundamento em \u00e1reas espec\u00edficas.</li> <li>Agradecer a todos que acompanharam esta s\u00e9rie de aulas.</li> </ul>"},{"location":"12/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Estamos chegando ao final de nossa jornada juntos neste curso. Durante esse tempo, tivemos a oportunidade de explorar uma s\u00e9rie de conceitos e tecnologias essenciais para o desenvolvimento de aplica\u00e7\u00f5es web modernas e escal\u00e1veis. \u00c9 importante lembrar que o que vimos aqui \u00e9 apenas a ponta do iceberg. Ainda h\u00e1 muitos aspectos e detalhes que n\u00e3o pudemos cobrir neste curso, como tratamento de logs, observabilidade, seguran\u00e7a avan\u00e7ada, otimiza\u00e7\u00f5es de desempenho, entre outros. Encorajo a todos que continuem explorando e aprendendo.</p>"},{"location":"12/#revisao","title":"Revis\u00e3o","text":"<p>Ao longo deste curso, cobrimos uma s\u00e9rie de t\u00f3picos essenciais para o desenvolvimento de aplica\u00e7\u00f5es web modernas e robustas:</p> <ul> <li> <p>FastAPI: Conhecemos e utilizamos o FastAPI, um moderno framework de desenvolvimento web para Python, que nos permite criar APIs de alto desempenho de forma eficiente e com menos c\u00f3digo.</p> </li> <li> <p>Docker: Aprendemos a utilizar o Docker para criar um ambiente isolado e replic\u00e1vel para nossa aplica\u00e7\u00e3o, o que facilita tanto o desenvolvimento quanto o deploy em produ\u00e7\u00e3o.</p> </li> <li> <p>Testes e TDD: Abordamos a import\u00e2ncia dos testes automatizados e da metodologia TDD (Test Driven Development) para garantir a qualidade e a confiabilidade do nosso c\u00f3digo.</p> </li> <li> <p>Banco de dados e migra\u00e7\u00f5es: Trabalhamos com bancos de dados SQL, utilizando o SQLAlchemy para a comunica\u00e7\u00e3o com o banco de dados, e o Alembic para gerenciar as migra\u00e7\u00f5es de banco de dados.</p> </li> <li> <p>Autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o: Implementamos funcionalidades de autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o, utilizando o padr\u00e3o JWT.</p> </li> <li> <p>Integra\u00e7\u00e3o Cont\u00ednua (CI): Utilizamos o Github Actions para criar um pipeline de CI, garantindo que os testes s\u00e3o sempre executados e que o c\u00f3digo mant\u00e9m uma qualidade constante.</p> </li> <li> <p>Deploy em produ\u00e7\u00e3o: Por fim, fizemos o deploy da nossa aplica\u00e7\u00e3o em um ambiente de produ\u00e7\u00e3o real, utilizando o Fly.io, e aprendemos a gerenciar e configurar esse ambiente.</p> </li> </ul>"},{"location":"12/#conclusao","title":"Conclus\u00e3o","text":"<p>Todos esses conceitos e pr\u00e1ticas s\u00e3o componentes fundamentais no desenvolvimento de aplica\u00e7\u00f5es web modernas e escal\u00e1veis. Eles nos permitem criar aplica\u00e7\u00f5es robustas, confi\u00e1veis e eficientes, que podem ser facilmente mantidas e escaladas.</p> <p>Gostaria de agradecer a todos que acompanharam essa s\u00e9rie de aulas. Espero que tenham encontrado valor nas informa\u00e7\u00f5es e pr\u00e1ticas que compartilhamos aqui. Lembre-se, a jornada do aprendizado \u00e9 cont\u00ednua e cada passo conta. Continue explorando, aprendendo e crescendo.</p> <p>At\u00e9 a pr\u00f3xima!</p>"}]}